"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.moveJobsToWait = void 0;
const content = `--[[
  Attempts to retry all failed jobs
  Input:
    KEYS[1] base key
    KEYS[2] events stream
    KEYS[3] state key (failed, completed, delayed)
    KEYS[4] 'wait'
    KEYS[5] 'paused'
    KEYS[6] 'meta'
    KEYS[7] 'active'
    KEYS[8] 'marker'
    ARGV[1] count
    ARGV[2] timestamp
    ARGV[3] prev state
  Output:
    1  means the operation is not completed
    0  means the operation is completed
]]
local maxCount = tonumber(ARGV[1])
local timestamp = tonumber(ARGV[2])
local rcall = redis.call;
-- Includes
--[[
  Add marker if needed when a job is available.
]]
local function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)
  if not isPausedOrMaxed then
    rcall("ZADD", markerKey, 0, "0")
  end  
end
--[[
  Function to loop in batches.
  Just a bit of warning, some commands as ZREM
  could receive a maximum of 7000 parameters per call.
]]
local function batches(n, batchSize)
  local i = 0
  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end
--[[
  Function to get max events value or set by default 10000.
]]
local function getOrSetMaxEvents(metaKey)
    local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")
    if not maxEvents then
        maxEvents = 10000
        rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)
    end
    return maxEvents
end
--[[
  Function to check for the meta.paused key to decide if we are paused or not
  (since an empty list and !EXISTS are not really the same).
]]
local function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)
  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")
  if queueAttributes[1] then
    return pausedKey, true
  else
    if queueAttributes[2] then
      local activeCount = rcall("LLEN", activeKey)
      if activeCount >= tonumber(queueAttributes[2]) then
        return waitKey, true
      else
        return waitKey, false
      end
    end
  end
  return waitKey, false
end
local function setGroupRateLimitedIfNeeded(prefixKey, groupId, isRateLimited, timestamp, ttl)
  local groupsKey = prefixKey .. 'groups'
  if not isRateLimited then
    local highscore = rcall("ZREVRANGE", groupsKey, 0, 0,
                            "withscores")[2] or 0
    rcall("ZADD", groupsKey, highscore + 1, groupId)
  else
    local groupsRateLimitKey = groupsKey .. ':limit'
    local nextTimestamp = timestamp + ttl
    rcall("ZADD", groupsRateLimitKey, nextTimestamp, groupId)
  end
end
local function batchAddToGroup(prefixKey, groupId, jobsTable, waitKey, timestamp)
  local groupKey = prefixKey .. 'groups:' .. groupId
  for from, to in batches(#jobsTable, 7000) do
    rcall("LPUSH", groupKey, unpack(jobsTable, from, to))
  end
  --if group is paused we do not need to check for rate limit
  if rcall("ZSCORE", prefixKey .. 'groups:paused', groupId) ~= false then
    return
  else
    -- Has this group reached maximum concurrency?
    local hasReachedMaxConcurrency = rcall("ZSCORE", prefixKey .. 'groups:max', groupId) ~= false
    -- Is group rate limited?
    local groupRateLimitKey = groupKey .. ':limit'
    local jobCounter = tonumber(rcall("GET", groupRateLimitKey))
    local isRateLimited = jobCounter and jobCounter >= 999999
    if hasReachedMaxConcurrency or isRateLimited or rcall("LLEN", waitKey) > 0 then
      -- First item in a group, we need to add this groupId to the groupsIds zset
      -- or if rate limited to the groups rate limited zset.
      if not hasReachedMaxConcurrency then
        local ttl = tonumber(rcall("PTTL", groupRateLimitKey))
        setGroupRateLimitedIfNeeded(prefixKey, groupId, isRateLimited, timestamp, ttl)
      end
    else
      local groupsKey = prefixKey .. 'groups'
      local highscore = rcall("ZREVRANGE", groupsKey, 0, 0,
        "withscores")[2] or 0
      rcall("ZADD", groupsKey, highscore + 1, groupId)
    end
  end
end
local target, isPausedOrMaxed = getTargetQueueList(KEYS[6], KEYS[7], KEYS[4], KEYS[5])
local jobs = rcall('ZRANGEBYSCORE', KEYS[3], 0, timestamp, 'LIMIT', 0, maxCount)
if (#jobs > 0) then
  local nonGroupJobs = {}
  local groupJobs = {}
  local maxEvents = getOrSetMaxEvents(KEYS[6])
  for i, key in ipairs(jobs) do
    local jobKey = KEYS[1] .. key
    if ARGV[3] == "failed" then
      for i, key in ipairs(jobs) do
        rcall("HDEL", jobKey, "finishedOn", "processedOn", "failedReason")
      end
    elseif ARGV[3] == "completed" then
      for i, key in ipairs(jobs) do
        rcall("HDEL", jobKey, "finishedOn", "processedOn", "returnvalue")
      end
    end
    local groupId = rcall("HGET", jobKey, "gid")
    if groupId ~= false then
      if groupJobs[groupId] == nil then
        groupJobs[groupId] = {}
      end
      table.insert(groupJobs[groupId], key)
    else
      table.insert(nonGroupJobs, key)
    end
    -- Emit waiting event
    rcall("XADD", KEYS[2], "MAXLEN", "~", maxEvents, "*", "event", "waiting",
      "jobId", key, "prev", ARGV[3]);
  end
  if #jobs == #nonGroupJobs then
    for from, to in batches(#jobs, 7000) do
      rcall("ZREM", KEYS[3], unpack(jobs, from, to))
      rcall("LPUSH", target, unpack(jobs, from, to))
    end
  else
    for from, to in batches(#jobs, 7000) do
      rcall("ZREM", KEYS[3], unpack(jobs, from, to))
    end
    for groupId, jobsTable in pairs(groupJobs) do
      batchAddToGroup(KEYS[1], groupId, jobsTable, target, timestamp)
    end
    for from, to in batches(#nonGroupJobs, 7000) do
      rcall("LPUSH", target, unpack(nonGroupJobs, from, to))
    end
  end
  addBaseMarkerIfNeeded(KEYS[8], isPausedOrMaxed)
end
maxCount = maxCount - #jobs
if(maxCount <= 0) then
  return 1
end
return 0
`;
exports.moveJobsToWait = {
    name: 'moveJobsToWait',
    content,
    keys: 8,
};
//# sourceMappingURL=moveJobsToWait-8.js.map