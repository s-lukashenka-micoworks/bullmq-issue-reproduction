"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.retryJob = void 0;
const content = `--[[
  Retries a failed job by moving it back to the wait queue.
    Input:
      KEYS[1]  'active',
      KEYS[2]  'wait'
      KEYS[3]  'paused'
      KEYS[4]  job key
      KEYS[5]  'meta'
      KEYS[6]  events stream
      KEYS[7]  delayed key
      KEYS[8]  prioritized key
      KEYS[9]  'pc' priority counter
      KEYS[10] 'marker'
      KEYS[11] 'stalled'
      ARGV[1]  key prefix
      ARGV[2]  timestamp
      ARGV[3]  pushCmd
      ARGV[4]  jobId
      ARGV[5]  token
      ARGV[6]  concurrency
    Events:
      'waiting'
    Output:
     0  - OK
     -1 - Missing key
     -2 - Missing lock
     -3 - Job not in active set
]]
local rcall = redis.call
-- Includes
--[[
  Function to get max events value or set by default 10000.
]]
local function getOrSetMaxEvents(metaKey)
    local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")
    if not maxEvents then
        maxEvents = 10000
        rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)
    end
    return maxEvents
end
--[[
  Function to check for the meta.paused key to decide if we are paused or not
  (since an empty list and !EXISTS are not really the same).
]]
local function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)
  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")
  if queueAttributes[1] then
    return pausedKey, true
  else
    if queueAttributes[2] then
      local activeCount = rcall("LLEN", activeKey)
      if activeCount >= tonumber(queueAttributes[2]) then
        return waitKey, true
      else
        return waitKey, false
      end
    end
  end
  return waitKey, false
end
local function removeLock(jobKey, stalledKey, token, jobId)
  if token ~= "0" then
    local lockKey = jobKey .. ':lock'
    local lockToken = rcall("GET", lockKey)
    if lockToken == token then
      rcall("DEL", lockKey)
      rcall("SREM", stalledKey, jobId)
    else
      if lockToken then
        -- Lock exists but token does not match
        return -6
      else
        -- Lock is missing completely
        return -2
      end
    end
  end
  return 0
end
--[[
  Function to add job considering priority.
]]
-- Includes
--[[
  Add marker if needed when a job is available.
]]
local function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)
  if not isPausedOrMaxed then
    rcall("ZADD", markerKey, 0, "0")
  end  
end
local function addJobWithPriority(markerKey, prioritizedKey, priority, jobId,
    priorityCounterKey, isPausedOrMaxed, groupId)
  local prioCounter
  if groupId then
    prioCounter = rcall("HINCRBY", priorityCounterKey, groupId, 1)
  else
    prioCounter = rcall("INCR", priorityCounterKey)
  end
  local score = priority * 0x100000000 + prioCounter % 0x100000000
  rcall("ZADD", prioritizedKey, score, jobId)
  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)
end
-- Includes
--[[
  Function to add job in target list and add marker if needed.
]]
-- Includes
local function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)
  rcall(pushCmd, targetKey, jobId)
  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)
end
--[[
  Function to push back job considering priority in front of same prioritized jobs.
]]
local function pushBackJobWithPriority(prioritizedKey, priority, jobId)
  -- in order to put it at front of same prioritized jobs
  -- we consider prioritized counter as 0
  local score = priority * 0x100000000
  rcall("ZADD", prioritizedKey, score, jobId)
end
local function moveJobToTargetGroup(pushCmd, prefixKey, groupKey, groupId, jobId, markerKey, priority,
    isPaused, pushBack)
    if priority == 0 then
        addJobInTargetList(groupKey, markerKey, pushCmd, isPaused, jobId)
    elseif pushBack then
        pushBackJobWithPriority(groupKey .. ":p", priority, jobId)
    else
        addJobWithPriority(markerKey, groupKey .. ":p", priority, jobId,
            prefixKey .. "groups:pc", isPaused, groupId)
    end
end
local function addToGroup(lifo, prefixKey, groupId, jobId, markerKey, priority, isPaused, pushBack)
    local groupKey = prefixKey .. 'groups:' .. groupId
    local pushCmd = lifo and 'RPUSH' or 'LPUSH';
    --if group is paused we do not need to check for rate limit
    if rcall("ZSCORE", prefixKey .. 'groups:paused', groupId) ~= false then
        -- set isPaused as true in order to avoid adding marker
        moveJobToTargetGroup(pushCmd, prefixKey, groupKey, groupId, jobId, markerKey, priority, true, pushBack)
    else
        -- Has this group reached maximum concurrency?
        local hasReachedMaxConcurrency = rcall("ZSCORE", prefixKey .. 'groups:max', groupId) ~= false
        -- Is group rate limited?
        local groupRateLimitKey = groupKey .. ':limit'
        local jobCounter = tonumber(rcall("GET", groupRateLimitKey))
        local isRateLimited = jobCounter and jobCounter >= 999999
        if hasReachedMaxConcurrency or isRateLimited then
            -- set isPaused as true in order to avoid adding marker
            moveJobToTargetGroup(pushCmd, prefixKey, groupKey, groupId, jobId, markerKey, priority, true, pushBack)
        else
            moveJobToTargetGroup(pushCmd, prefixKey, groupKey, groupId, jobId, markerKey, priority, isPaused, pushBack)
            local groupsKey = prefixKey .. 'groups'
            local highscore = rcall("ZREVRANGE", groupsKey, 0, 0,
                "withscores")[2] or 0
            rcall("ZADD", groupsKey, highscore + 1, groupId)
        end
    end
end
--[[
  Function to decrease group concurrency.
  Returns true if group is removed from maxed.
]]
-- Includes
--[[
  Promote a maxed group (if any) so that it is not maxed anymore
]]
-- Includes
-- Includes
local function isGroupRateLimited(groupKey)
  local groupRateLimitKey = groupKey .. ':limit'
  local jobCounter = tonumber(rcall("GET", groupRateLimitKey))
  return jobCounter and jobCounter >= 999999
end
--[[
  Reinsert the group with the highest score so that it is moved to the last position
]]
local function reinsertGroupIfNeeded(groupKey, groupsKey, groupId)
  if rcall("LLEN", groupKey) > 0 or rcall("ZCARD", groupKey .. ":p") > 0 then
    local highscore = rcall("ZREVRANGE", groupsKey, 0, 0, "withscores")[2] or 0
    -- Note, this mechanism could keep increasing the score indefinetely.
    -- Score can represent 2^53 integers, so approximatelly 285 years adding 1M jobs/second
    -- before it starts misbehaving.
    rcall("ZADD", groupsKey, highscore + 1, groupId)
    return true
  else
    rcall("HDEL", groupsKey .. ":pc", groupId)
    return false
  end
end
local function reinsertGroupIfNotRateLimitedOrPaused(prefixKey, groupId)
  if rcall("ZSCORE", prefixKey .. "groups:paused", groupId) == false then
    local groupKey = prefixKey .. 'groups:' .. groupId
    if not isGroupRateLimited(groupKey) then
      local groupsKey = prefixKey .. 'groups'
      return reinsertGroupIfNeeded(groupKey, groupsKey, groupId)
    end
  end
end
local function promoteMaxedGroup(prefixKey, markerKey, paused, groupId)
    if rcall("ZREM", prefixKey .. "groups:max", groupId) > 0 then
        local groupsKey = prefixKey .. 'groups'
        if reinsertGroupIfNotRateLimitedOrPaused(prefixKey, groupId) then
            addBaseMarkerIfNeeded(markerKey, paused)
        end
    end
end
local function isGroupMaxed(prefixKey, groupId)
  return rcall("ZSCORE", prefixKey .. "groups:max", groupId) ~= false
end
local function decreaseGroupConcurrency(prefixKey, markerKey, paused, groupId, maxConcurrency)
    local activeCountKey = prefixKey .. "groups:active:count"
    local activeCount = rcall("HGET", activeCountKey, groupId)
    if activeCount then
        local count = rcall("HINCRBY", activeCountKey, groupId, -1)
        if count <= 0 then rcall("HDEL", activeCountKey, groupId) end
        local localConcurrency = rcall("HGET", prefixKey .. "groups:concurrency", groupId)
        -- We use maxConcurrency, in case the user decides to change it (lower it),
        -- we need to check it here so that we keep the group in active if necessary.
        if count < tonumber(localConcurrency or maxConcurrency) and
            isGroupMaxed(prefixKey, groupId) then
            promoteMaxedGroup(prefixKey, markerKey, paused, groupId)
            return true
        end
    end
    return false
end
--[[
  Updates the delay set, by moving delayed jobs that should
  be processed now to "wait".
    Events:
      'waiting'
]]
-- Includes
-- Try to get as much as 1000 jobs at once, and returns the nextTimestamp if
-- there are more delayed jobs to process.
local function promoteDelayedJobs(delayedKey, markerKey, targetKey, prioritizedKey,
                                  eventStreamKey, prefix, timestamp, priorityCounterKey, paused)
    local jobs = rcall("ZRANGEBYSCORE", delayedKey, 0, (timestamp + 1) * 0x1000 - 1, "LIMIT", 0, 1000)
    if (#jobs > 0) then
        rcall("ZREM", delayedKey, unpack(jobs))
        for _, jobId in ipairs(jobs) do
            local jobKey = prefix .. jobId
            local jobAttributes = rcall("HMGET", jobKey, "priority", "gid")
            local priority = tonumber(jobAttributes[1]) or 0
            -- Standard or priority add
            if jobAttributes[2] then
                addToGroup(false, prefix, jobAttributes[2], jobId, markerKey,
                    priority, paused, false)
            elseif priority == 0 then
                -- LIFO or FIFO
                addJobInTargetList(targetKey, markerKey, "LPUSH", paused, jobId)
            else
                addJobWithPriority(markerKey, prioritizedKey, priority,
                  jobId, priorityCounterKey, paused, nil)
            end
            -- Emit waiting event
            rcall("XADD", eventStreamKey, "*", "event", "waiting", "jobId",
                  jobId, "prev", "delayed")
            rcall("HSET", jobKey, "delay", 0)
        end
    end
end
local target, isPausedOrMaxed = getTargetQueueList(KEYS[5], KEYS[1], KEYS[2], KEYS[3])
local markerKey = KEYS[10]
local prioritizedKey = KEYS[8]
local jobKey = KEYS[4]
local prefixKey = ARGV[1]
-- Check if there are delayed jobs that we can move to wait.
-- test example: when there are delayed jobs between retries
promoteDelayedJobs(KEYS[7], markerKey, target, prioritizedKey, KEYS[6], prefixKey,
  ARGV[2], KEYS[9], isPausedOrMaxed)
if rcall("EXISTS", jobKey) == 1 then
  local errorCode = removeLock(KEYS[4], KEYS[11], ARGV[5], ARGV[4]) 
  if errorCode < 0 then
    return errorCode
  end
  local numRemovedElements = rcall("LREM", KEYS[1], -1, ARGV[4])
  if (numRemovedElements < 1) then return -3 end
  local jobAttributes = rcall("HMGET", jobKey, "priority", "gid")
  local priority = tonumber(jobAttributes[1]) or 0
  if jobAttributes[2] then
    decreaseGroupConcurrency(prefixKey, markerKey, isPausedOrMaxed, jobAttributes[2], tonumber(ARGV[6] or 999999))
    --TODO: revisit addToGroup to add marker when needed
    addToGroup(false, prefixKey, jobAttributes[2], ARGV[4], markerKey, priority, isPausedOrMaxed, false)
  elseif priority == 0 then
    rcall(ARGV[3], target, ARGV[4])
  else
    addJobWithPriority(markerKey, prioritizedKey, priority, ARGV[4], KEYS[9], isPausedOrMaxed, nil)
  end
  rcall("HINCRBY", jobKey, "atm", 1)
  local maxEvents = getOrSetMaxEvents(KEYS[5])
  -- Emit waiting event
  rcall("XADD", KEYS[6], "MAXLEN", "~", maxEvents, "*", "event", "waiting", "jobId", ARGV[4],
    "prev", "failed");
  return 0
else
  return -1
end
`;
exports.retryJob = {
    name: 'retryJob',
    content,
    keys: 11,
};
//# sourceMappingURL=retryJob-11.js.map