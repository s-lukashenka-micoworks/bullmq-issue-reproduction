--[[
  Retries a failed job by moving it back to the wait queue.

    Input:
      KEYS[1]  'active',
      KEYS[2]  'wait'
      KEYS[3]  'paused'
      KEYS[4]  job key
      KEYS[5]  'meta'
      KEYS[6]  events stream
      KEYS[7]  delayed key
      KEYS[8]  prioritized key
      KEYS[9]  'pc' priority counter
      KEYS[10] 'marker'
      KEYS[11] 'stalled'

      ARGV[1]  key prefix
      ARGV[2]  timestamp
      ARGV[3]  pushCmd
      ARGV[4]  jobId
      ARGV[5]  token
      ARGV[6]  concurrency

    Events:
      'waiting'

    Output:
     0  - OK
     -1 - Missing key
     -2 - Missing lock
     -3 - Job not in active set
]]
local rcall = redis.call

-- Includes
--- @include "<base>/includes/getOrSetMaxEvents"
--- @include "<base>/includes/getTargetQueueList"
--- @include "<base>/includes/removeLock"
--- @include "includes/addJobWithPriority"
--- @include "includes/addToGroup"
--- @include "includes/decreaseGroupConcurrency"
--- @include "includes/promoteDelayedJobs"

local target, isPausedOrMaxed = getTargetQueueList(KEYS[5], KEYS[1], KEYS[2], KEYS[3])
local markerKey = KEYS[10]
local prioritizedKey = KEYS[8]
local jobKey = KEYS[4]
local prefixKey = ARGV[1]
-- Check if there are delayed jobs that we can move to wait.
-- test example: when there are delayed jobs between retries
promoteDelayedJobs(KEYS[7], markerKey, target, prioritizedKey, KEYS[6], prefixKey,
  ARGV[2], KEYS[9], isPausedOrMaxed)

if rcall("EXISTS", jobKey) == 1 then
  local errorCode = removeLock(KEYS[4], KEYS[11], ARGV[5], ARGV[4]) 
  if errorCode < 0 then
    return errorCode
  end

  local numRemovedElements = rcall("LREM", KEYS[1], -1, ARGV[4])
  if (numRemovedElements < 1) then return -3 end

  local jobAttributes = rcall("HMGET", jobKey, "priority", "gid")
  local priority = tonumber(jobAttributes[1]) or 0

  if jobAttributes[2] then
    decreaseGroupConcurrency(prefixKey, markerKey, isPausedOrMaxed, jobAttributes[2], tonumber(ARGV[6] or 999999))
    --TODO: revisit addToGroup to add marker when needed
    addToGroup(false, prefixKey, jobAttributes[2], ARGV[4], markerKey, priority, isPausedOrMaxed, false)
  elseif priority == 0 then
    rcall(ARGV[3], target, ARGV[4])
  else
    addJobWithPriority(markerKey, prioritizedKey, priority, ARGV[4], KEYS[9], isPausedOrMaxed, nil)
  end

  rcall("HINCRBY", jobKey, "atm", 1)

  local maxEvents = getOrSetMaxEvents(KEYS[5])

  -- Emit waiting event
  rcall("XADD", KEYS[6], "MAXLEN", "~", maxEvents, "*", "event", "waiting", "jobId", ARGV[4],
    "prev", "failed");
  
  return 0
else
  return -1
end
