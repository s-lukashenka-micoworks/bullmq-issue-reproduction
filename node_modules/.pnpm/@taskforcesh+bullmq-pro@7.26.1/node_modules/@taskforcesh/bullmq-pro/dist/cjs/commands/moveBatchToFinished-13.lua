--[[
  Move batch of jobs from active to a finished status (completed o failed)
  A job can only be moved to completed if it was active.

  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] prioritized key
      KEYS[4] stream events key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      KEYS[8] paused key
      KEYS[9] meta key
      KEYS[10] pc priority counter
      KEYS[11] completed/failed key
      KEYS[12] metrics key
      KEYS[13] marker key

      ARGV[1] args msgpack encoded
                jobs: {
                    id: string // job id
                    v: string // return value / failed reason
                    a: number // attempts
                    am: number // attempts made
                    fpof: boolean // fail parent on failure
                    kj: {
                        count: number // keep jobs count
                        age: number // keep jobs age
                    }
                }[]
                ts: number // timestamp
                f: string // value field name (propVal),
                t: string // target state (completed/failed)
                p: string // keys prefix
                ts: timestamp,
                fn: number // fetch next (number of jobs to fetch)

      ARGV[2] opts as msgpack encoded
                token: string // lock token
                lockDuration: number // lock duration in milliseconds
                maxMetricsSize: number // max metrics size
                group: {
                    concurrency: number // group concurrency
                }
    
     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.
      -3 Job not in active set
      -4 Job has pending dependencies
      -6 Lock is not owned by this client

     Events:
      'completed/failed'
]]
local rcall = redis.call

local waitKey = KEYS[1]
local activeKey = KEYS[2]

local priorityKey = KEYS[3]
local eventStreamKey = KEYS[4]
local stalledKey = KEYS[5]

local finishedKey = KEYS[11]
local metaKey = KEYS[9]
local metricsKey = KEYS[12]

local args = cmsgpack.unpack(ARGV[1])

local timestamp = args['ts']
local prefixKey = args['p']
local jobs = args['jobs']
local targetState = args['t']
local field = args['f']

local opts = cmsgpack.unpack(ARGV[2])

local token = opts['token']
local lockDuration = opts['lockDuration']
local maxMetricsSize = opts['maxMetricsSize']

--- @include "<base>/includes/collectMetrics"
--- @include "<base>/includes/destructureJobKey"
--- @include "<base>/includes/getRateLimitTTL"
--- @include "<base>/includes/getTargetQueueList"
--- @include "<base>/includes/moveParentFromWaitingChildrenToFailed"
--- @include "<base>/includes/removeJob"
--- @include "<base>/includes/removeJobsByMaxAge"
--- @include "<base>/includes/removeJobsByMaxCount"
--- @include "<base>/includes/removeJobKeys"
--- @include "<base>/includes/removeParentDependencyKey"
--- @include "<base>/includes/trimEvents"
--- @include "includes/decreaseGroupConcurrency"
--- @include "includes/promoteDelayedJobs"
--- @include "includes/promoteRateLimitedGroups"
--- @include "includes/moveNextBatch"
--- @include "includes/moveParentToWaitIfNeeded"
--- @include "includes/updateParentDepsIfNeeded"

local target, isPausedOrMaxed = getTargetQueueList(metaKey, activeKey, waitKey, KEYS[8])
local markerKey = KEYS[13]
local rateLimitedNextTtl = promoteRateLimitedGroups(prefixKey, markerKey,
                                                    timestamp, isPausedOrMaxed)

-- Trim events before emiting them to avoid trimming events emitted in this script
trimEvents(metaKey, eventStreamKey)

-- TODO: Refactor and reuse in moveToFinished
local function moveJobToFinished(job)
    local jobKey = prefixKey .. job['id']

    local jobId = job['id']
    local value = job['v']
    local fpof = job['fpof']
    local attempts = job['a']

    local maxCount = job['kj']['count']
    local maxAge = job['kj']['age']

    if rcall("EXISTS", jobKey) == 1 then -- // Make sure job exists
        if token ~= "0" then
            local lockKey = jobKey .. ':lock'
            local lockToken = rcall("GET", lockKey)
            if lockToken == token then
                rcall("DEL", lockKey)
                rcall("SREM", stalledKey, jobId)
            else
                if lockToken then
                    -- Lock exists but token does not match
                    return -6
                else
                    -- Lock is missing completely
                    return -2
                end
            end
        end

        if rcall("SCARD", jobKey .. ":dependencies") ~= 0 then -- // Make sure it does not have pending dependencies
            return -4
        end

        local parentReferences = rcall("HMGET", jobKey, "parentKey", "parent")
        local parentKey = parentReferences[1] or ""
        local parentId = ""
        local parentQueueKey = ""
        if parentReferences[2] ~= false then
            local jsonDecodedParent = cjson.decode(parentReferences[2])
            parentId = jsonDecodedParent['id']
            parentQueueKey = jsonDecodedParent['queueKey']
        end

        -- Remove from active list (if not active we shall return error)
        local numRemovedElements = rcall("LREM", activeKey, -1, jobId)
        if (numRemovedElements < 1) then return -3 end

        -- Update the active group count and set.
        local jobKey = prefixKey .. jobId
        local groupId = rcall("HGET", jobKey, "gid")

        if groupId then
            local maxConcurrency = opts['group'] and
                                       opts['group']['concurrency']
            decreaseGroupConcurrency(prefixKey, markerKey, isPausedOrMaxed, groupId,
                maxConcurrency or 999999)
        end

        -- If job has a parent we need to 
        -- 1) remove this job id from parents dependencies
        -- 2) move the job Id to parent "processed" set
        -- 3) push the results into parent "results" list
        -- 4) if parent's dependencies is empty, then move parent to "wait/paused". Note it may be a different queue!.
        -- NOTE: Priorities not supported yet for parent jobs.

        -- local parentQueueKey = ARGV[13]
        if parentId == "" and parentKey ~= "" then
            parentId = getJobIdFromKey(parentKey)
            parentQueueKey = getJobKeyPrefix(parentKey, ":" .. parentId)
        end
        if parentId ~= "" then
            if targetState == "completed" then
                local dependenciesSet = parentKey .. ":dependencies"
                if rcall("SREM", dependenciesSet, jobKey) == 1 then
                    updateParentDepsIfNeeded(parentKey, parentQueueKey,
                                             dependenciesSet, parentId, jobKey,
                                             value, timestamp)
                end
            else
                if fpof then
                    moveParentFromWaitingChildrenToFailed(parentQueueKey, parentKey,
                        parentId, jobIdKey, timestamp)
                elseif rdof then
                    local dependenciesSet = parentKey .. ":dependencies"
                    if rcall("SREM", dependenciesSet, jobIdKey) == 1 then
                        moveParentToWaitIfNeeded(parentQueueKey, dependenciesSet,
                            parentKey, parentId, timestamp)
                    end
                end
            end
        end

        local attemptsMade = rcall("HINCRBY", jobKey, "atm", 1)

        -- Remove finished job?
        if maxCount ~= 0 then
            local targetSet = finishedKey
            -- Add to complete/failed set
            rcall("ZADD", targetSet, timestamp, jobId)
            rcall("HMSET", jobKey, field, value, "finishedOn", timestamp)
            -- "returnvalue" / "failedReason" and "finishedOn"

            -- Remove old jobs?
            if maxAge ~= nil then
                removeJobsByMaxAge(timestamp, maxAge, targetSet, prefixKey)
            end

            if maxCount ~= nil and maxCount > 0 then
                removeJobsByMaxCount(maxCount, targetSet, prefixKey)
            end
        else
            removeJobKeys(jobKey)
            if parentKey ~= "" then
                removeParentDependencyKey(jobKey, false, parentKey)
            end
        end

        rcall("XADD", eventStreamKey, "*", "event", targetState, "jobId", jobId,
              field, value)

        if targetState == "failed" then
            if tonumber(attemptsMade) >= tonumber(attempts) then
                rcall("XADD", eventStreamKey, "*", "event", "retries-exhausted",
                      "jobId", jobId, "attemptsMade", attemptsMade)
            end
        end

        -- Collect metrics
        if maxMetricsSize ~= "" then
            collectMetrics(metricsKey, metricsKey .. ':data', maxMetricsSize,
                           timestamp)
        end

        return {0, 0, 0, rateLimitedNextTtl}
    else
        return -1
    end
end

-- Iterate over all jobs and move them to finished
local results = {}
for _, job in ipairs(jobs) do
    local result = moveJobToFinished(job)
    table.insert(results, result)
end

-- If the queue is paused we just return
if isPausedOrMaxed then return results end

local delayedKey = KEYS[7]

-- Check if there are delayed jobs that can be promoted
promoteDelayedJobs(delayedKey, markerKey, target, priorityKey,
                   eventStreamKey, prefixKey, timestamp, KEYS[10], isPausedOrMaxed)

-- If there are errors we must return the errors instead.
for _, result in ipairs(results) do
    local resultType = type(result)
    if resultType == "number" and result < 0 then return results end
end

-- Move next batch of jobs to active
local numJobs = args['fn']
if numJobs then
    local rateLimiterKey = KEYS[6]
    local maxJobs = tonumber(opts['limiter'] and opts['limiter']['max'])
    local expireTime = getRateLimitTTL(maxJobs, rateLimiterKey)
    if expireTime > 0 then return {{}, {}, expireTime, 0} end

    return moveNextBatch(waitKey, activeKey, delayedKey, rateLimiterKey,
                         eventStreamKey, prefixKey, opts, numJobs, timestamp,
                         markerKey, rateLimiterKey, maxJobs, KEYS)
else
    return results
end
