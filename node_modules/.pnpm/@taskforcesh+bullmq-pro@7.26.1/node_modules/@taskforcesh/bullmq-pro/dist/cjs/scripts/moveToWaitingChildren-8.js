"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.moveToWaitingChildren = void 0;
const content = `--[[
  Moves job from active to waiting children set.
  Input:
    KEYS[1] prefix key
    KEYS[2] lock key
    KEYS[3] active key
    KEYS[4] waitChildrenKey key
    KEYS[5] job key
    KEYS[6] stalled key
    KEYS[7] marker key
    KEYS[8] meta key
    ARGV[1] token
    ARGV[2] child key
    ARGV[3] timestamp
    ARGV[4] the id of the job
    ARGV[5] concurrency
  Output:
    0 - OK
    1 - There are not pending dependencies.
   -1 - Missing job.
   -2 - Missing lock
   -3 - Job not in active set
]]
local rcall = redis.call
-- Includes
--[[
  Function to check for the meta.paused key to decide if we are paused or not
  (since an empty list and !EXISTS are not really the same).
]]
local function isQueuePaused(queueMetaKey)
  return rcall("HEXISTS", queueMetaKey, "paused") == 1
end
local function removeLock(jobKey, stalledKey, token, jobId)
  if token ~= "0" then
    local lockKey = jobKey .. ':lock'
    local lockToken = rcall("GET", lockKey)
    if lockToken == token then
      rcall("DEL", lockKey)
      rcall("SREM", stalledKey, jobId)
    else
      if lockToken then
        -- Lock exists but token does not match
        return -6
      else
        -- Lock is missing completely
        return -2
      end
    end
  end
  return 0
end
--[[
  Function to decrease group concurrency.
  Returns true if group is removed from maxed.
]]
-- Includes
--[[
  Promote a maxed group (if any) so that it is not maxed anymore
]]
-- Includes
--[[
  Add marker if needed when a job is available.
]]
local function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)
  if not isPausedOrMaxed then
    rcall("ZADD", markerKey, 0, "0")
  end  
end
-- Includes
local function isGroupRateLimited(groupKey)
  local groupRateLimitKey = groupKey .. ':limit'
  local jobCounter = tonumber(rcall("GET", groupRateLimitKey))
  return jobCounter and jobCounter >= 999999
end
--[[
  Reinsert the group with the highest score so that it is moved to the last position
]]
local function reinsertGroupIfNeeded(groupKey, groupsKey, groupId)
  if rcall("LLEN", groupKey) > 0 or rcall("ZCARD", groupKey .. ":p") > 0 then
    local highscore = rcall("ZREVRANGE", groupsKey, 0, 0, "withscores")[2] or 0
    -- Note, this mechanism could keep increasing the score indefinetely.
    -- Score can represent 2^53 integers, so approximatelly 285 years adding 1M jobs/second
    -- before it starts misbehaving.
    rcall("ZADD", groupsKey, highscore + 1, groupId)
    return true
  else
    rcall("HDEL", groupsKey .. ":pc", groupId)
    return false
  end
end
local function reinsertGroupIfNotRateLimitedOrPaused(prefixKey, groupId)
  if rcall("ZSCORE", prefixKey .. "groups:paused", groupId) == false then
    local groupKey = prefixKey .. 'groups:' .. groupId
    if not isGroupRateLimited(groupKey) then
      local groupsKey = prefixKey .. 'groups'
      return reinsertGroupIfNeeded(groupKey, groupsKey, groupId)
    end
  end
end
local function promoteMaxedGroup(prefixKey, markerKey, paused, groupId)
    if rcall("ZREM", prefixKey .. "groups:max", groupId) > 0 then
        local groupsKey = prefixKey .. 'groups'
        if reinsertGroupIfNotRateLimitedOrPaused(prefixKey, groupId) then
            addBaseMarkerIfNeeded(markerKey, paused)
        end
    end
end
local function isGroupMaxed(prefixKey, groupId)
  return rcall("ZSCORE", prefixKey .. "groups:max", groupId) ~= false
end
local function decreaseGroupConcurrency(prefixKey, markerKey, paused, groupId, maxConcurrency)
    local activeCountKey = prefixKey .. "groups:active:count"
    local activeCount = rcall("HGET", activeCountKey, groupId)
    if activeCount then
        local count = rcall("HINCRBY", activeCountKey, groupId, -1)
        if count <= 0 then rcall("HDEL", activeCountKey, groupId) end
        local localConcurrency = rcall("HGET", prefixKey .. "groups:concurrency", groupId)
        -- We use maxConcurrency, in case the user decides to change it (lower it),
        -- we need to check it here so that we keep the group in active if necessary.
        if count < tonumber(localConcurrency or maxConcurrency) and
            isGroupMaxed(prefixKey, groupId) then
            promoteMaxedGroup(prefixKey, markerKey, paused, groupId)
            return true
        end
    end
    return false
end
local jobKey = KEYS[5]
local workerConcurrency = ARGV[5]
local function moveToWaitingChildren (activeKey, waitingChildrenKey, jobId,
  timestamp, prefix, metaKey, markerKey, groupId, concurrency)
  local score = tonumber(timestamp)
  local paused = isQueuePaused(metaKey)
  local numRemovedElements = rcall("LREM", activeKey, -1, jobId)
  if(numRemovedElements < 1) then
    return -3
  end
  if groupId then
    decreaseGroupConcurrency(prefix, markerKey, paused, groupId,
      tonumber(concurrency or 999999))
  end
  rcall("ZADD", waitingChildrenKey, score, jobId)
  return 0
end
if rcall("EXISTS", jobKey) == 1 then
  local markerKey = KEYS[7]
  local metaKey = KEYS[8]
  if ARGV[2] ~= "" then
    if rcall("SISMEMBER", jobKey .. ":dependencies", ARGV[2]) ~= 0 then
      local errorCode = removeLock(jobKey, KEYS[6], ARGV[1], ARGV[4])
      if errorCode < 0 then
        return errorCode
      end
      local groupId = rcall("HGET", jobKey, "gid")
      return moveToWaitingChildren(KEYS[3], KEYS[4], ARGV[4],
              ARGV[3], KEYS[1], metaKey, markerKey, groupId, workerConcurrency)
    end
    return 1
  else
    if rcall("SCARD", jobKey .. ":dependencies") ~= 0 then 
      local errorCode = removeLock(jobKey, KEYS[6], ARGV[1], ARGV[4])
      if errorCode < 0 then
        return errorCode
      end
      local groupId = rcall("HGET", jobKey, "gid")
      return moveToWaitingChildren(KEYS[3], KEYS[4], ARGV[4],
              ARGV[3], KEYS[1], metaKey, markerKey, groupId, workerConcurrency)
    end
    return 1
  end
end
return -1
`;
exports.moveToWaitingChildren = {
    name: 'moveToWaitingChildren',
    content,
    keys: 8,
};
//# sourceMappingURL=moveToWaitingChildren-8.js.map