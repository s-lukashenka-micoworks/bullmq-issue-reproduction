"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueuePro = void 0;
const bullmq_1 = require("bullmq");
const scripts_pro_1 = require("../classes/scripts-pro");
const group_status_1 = require("../enums/group-status");
const job_pro_1 = require("./job-pro");
const redis_connection_pro_1 = require("./redis-connection-pro");
const version_1 = require("../version");
const telemetry_pro_enum_1 = require("../enums/telemetry-pro.enum");
/**
 * QueuePro extends the functionality of Queue with additional
 * features for handling job groups, rate limiting, concurrency
 * per group, and more.
 *
 * @template DataType - The type of the job data.
 * @template ResultType - The type of the job result.
 * @template NameType - The type of the job name.
 *
 */
class QueuePro extends bullmq_1.Queue {
    constructor(name, opts) {
        super(name, opts, redis_connection_pro_1.RedisConnectionPro);
        this.libName = 'bullmq-pro';
    }
    setScripts() {
        this.scripts = new scripts_pro_1.ScriptsPro(this);
    }
    get metaValues() {
        var _a, _b, _c, _d;
        return {
            'opts.maxLenEvents': (_d = (_c = (_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.streams) === null || _b === void 0 ? void 0 : _b.events) === null || _c === void 0 ? void 0 : _c.maxLen) !== null && _d !== void 0 ? _d : 10000,
            version: `${this.libName}:${version_1.version}`,
        };
    }
    /**
     * Get library version.
     *
     * @returns the content of the meta.library field.
     */
    async getVersion() {
        const client = await this.client;
        return await client.hget(this.keys.meta, 'version');
    }
    /**
     * Adds a Job to the queue.
     *
     * @param name -2
     * @param data -
     * @param opts -
     */
    add(name, data, opts) {
        return this.trace(bullmq_1.SpanKind.PRODUCER, 'add', `${this.name}.${name}`, async (span, srcPropagationMedatada) => {
            var _a, _b;
            if (srcPropagationMedatada &&
                (opts === null || opts === void 0 ? void 0 : opts.telemetry) &&
                !((_a = opts === null || opts === void 0 ? void 0 : opts.telemetry) === null || _a === void 0 ? void 0 : _a.omitContext)) {
                const telemetry = Object.assign(Object.assign({}, opts.telemetry), { metadata: srcPropagationMedatada });
                opts.telemetry = telemetry;
            }
            const job = (await super.addJob(name, data, opts));
            if (span) {
                span.setAttributes({
                    [bullmq_1.TelemetryAttributes.JobName]: name,
                    [bullmq_1.TelemetryAttributes.JobId]: job.id,
                });
                if ((_b = opts === null || opts === void 0 ? void 0 : opts.group) === null || _b === void 0 ? void 0 : _b.id) {
                    span.setAttributes({
                        [telemetry_pro_enum_1.TelemetryAttributesPro.GroupId]: opts.group.id,
                        [telemetry_pro_enum_1.TelemetryAttributesPro.GroupMaxSize]: opts.group.maxSize,
                    });
                }
            }
            return job;
        });
    }
    /**
     * Adds an array of jobs to the queue. This method may be faster than adding
     * one job at a time in a sequence.
     *
     * @param jobs - The array of jobs to add to the queue. Each job is defined by 3
     * properties, 'name', 'data' and 'opts'. They follow the same signature as 'Queue.add'.
     */
    async addBulk(jobs) {
        if (jobs.some(jobs => { var _a, _b; return (_b = (_a = jobs.opts) === null || _a === void 0 ? void 0 : _a.group) === null || _b === void 0 ? void 0 : _b.maxSize; })) {
            throw new Error('Group max size is not supported in addBulk');
        }
        return super.addBulk(jobs);
    }
    get Job() {
        return job_pro_1.JobPro;
    }
    /**
     * Get the group ids with jobs current jobs in them.
     *
     * TODO: Support group id filtering.
     */
    async getGroups(start = 0, end = -1) {
        if (end < -1) {
            throw new Error('end must be greater than -1');
        }
        const [groups, rateLimited, maxConcurrencyGroups, pausedGroups] = await this.scripts.getGroups(start, end);
        // Combine results into a single array
        return [
            ...(groups || []).map(group => ({
                id: group,
                status: group_status_1.GroupStatus.Waiting,
            })),
            ...(rateLimited || []).map(group => ({
                id: group,
                status: group_status_1.GroupStatus.Limited,
            })),
            ...(maxConcurrencyGroups || []).map(group => ({
                id: group,
                status: group_status_1.GroupStatus.Maxed,
            })),
            ...(pausedGroups || []).map(group => ({
                id: group,
                status: group_status_1.GroupStatus.Paused,
            })),
        ];
    }
    /**
     * Gets all the groups that are in a particular status.
     *
     * @param status - GroupStatus so we can filter by status
     * @param start - start index, used for pagination.
     * @param end - end index, used for pagination.
     * @returns  an array of objects with the group id and status.
     */
    async getGroupsByStatus(status, start = 0, end = -1) {
        if (end < -1) {
            throw new Error('end must be greater than -1');
        }
        const [groupIds = [], counts = []] = await this.scripts.getGroupsByStatus(status, start, end);
        return groupIds.map((id, index) => ({
            id,
            count: counts[index],
        }));
    }
    /**
     * Get the total number of groups with jobs in them.
     *
     */
    async getGroupsCount() {
        const { waiting, limited, maxed, paused } = await this.getGroupsCountByStatus();
        return waiting + limited + maxed + paused;
    }
    /**
     *
     * Get the total number of groups with jobs in them, in their different
     * statuses.
     *
     * @returns {
     *    waiting: number,
     *    limited: number,
     *    maxed: number,
     *    paused: number,
     * }
     *
     */
    async getGroupsCountByStatus() {
        const client = await this.client;
        const multi = client.multi();
        multi.zcard(this.toKey('groups'));
        multi.zcard(this.toKey('groups:limit'));
        multi.zcard(this.toKey('groups:max'));
        multi.zcard(this.toKey('groups:paused'));
        const [[err1, waiting], [err2, limited], [err3, maxed], [err4, paused]] = (await multi.exec());
        const err = [err1, err2, err3, err4].find(err => !!err);
        if (err) {
            throw err;
        }
        return {
            waiting,
            limited,
            maxed,
            paused,
        };
    }
    /**
     * Returns the number of jobs per priority.
     */
    async getCountsPerPriorityForGroup(groupId, priorities) {
        const uniquePriorities = [...new Set(priorities)];
        const responses = await this.scripts.getCountsPerPriorityForGroup(groupId, uniquePriorities);
        const counts = {};
        responses.forEach((res, index) => {
            counts[`${uniquePriorities[index]}`] = res || 0;
        });
        return counts;
    }
    /**
     * Gets the count of all the jobs belonging to any group.
     *
     * @param limit - limit of groups per each iteration
     */
    async getGroupsJobsCount(limit = 100) {
        const client = await this.client;
        let count = 0;
        let start = 0;
        let groupState = 'waiting';
        do {
            const [currentCount, currentGroupState, nextStartIndex] = await this.scripts.getGroupsCount(client, start, start + limit - 1, groupState);
            groupState = currentGroupState;
            if (currentCount) {
                count += currentCount;
                start = nextStartIndex;
            }
        } while (groupState);
        return count;
    }
    /**
     * Get the given group status.
     *
     * @param groupId - The group id to get the status for.
     * @returns GroupStatus - The status of the group or null if the group does not exist.
     */
    async getGroupStatus(groupId) {
        const client = await this.client;
        const multi = client.multi();
        multi.zscore(this.toKey('groups'), groupId);
        multi.zscore(this.toKey('groups:limit'), groupId);
        multi.zscore(this.toKey('groups:max'), groupId);
        multi.zscore(this.toKey('groups:paused'), groupId);
        const [[err1, waiting], [err2, limited], [err3, maxed], [err4, paused]] = (await multi.exec());
        if (err1 || err2 || err3 || err4) {
            throw err1 || err2 || err3 || err4;
        }
        if (waiting) {
            return group_status_1.GroupStatus.Waiting;
        }
        if (limited) {
            return group_status_1.GroupStatus.Limited;
        }
        if (maxed) {
            return group_status_1.GroupStatus.Maxed;
        }
        if (paused) {
            return group_status_1.GroupStatus.Paused;
        }
        return null;
    }
    /**
     * Get jobs that are part of a given group.
     *
     */
    async getGroupJobs(groupId, start = 0, end = -1) {
        const jobIds = await this.scripts.getGroupJobs(groupId, start, end);
        return Promise.all(jobIds.map(jobId => job_pro_1.JobPro.fromId(this, jobId)));
    }
    /**
     * Gets the count of jobs inside a given group id.
     *
     * @param groupId -
     */
    async getGroupJobsCount(groupId) {
        return this.scripts.getGroupJobsCount(groupId);
    }
    /**
     * Gets the active count of jobs inside a given group id. It will only return data when using concurrency per group,
     * otherwise it will return NaN.
     *
     * @param groupId -
     */
    async getGroupActiveCount(groupId) {
        const client = await this.client;
        const activeCount = await client.hget(this.toKey('groups:active:count'), `${groupId}`);
        return parseInt(activeCount || '0');
    }
    /**
     * Sets group concurrency.
     *
     * @param groupId -
     * @param concurrency -
     */
    async setGroupConcurrency(groupId, concurrency) {
        const client = await this.client;
        return client.hset(this.toKey('groups:concurrency'), `${groupId}`, `${concurrency}`);
    }
    /**
     * Deletes group concurrency.
     *
     * @param groupId -
     */
    async deleteGroupConcurrency(groupId) {
        const client = await this.client;
        return client.hdel(this.toKey('groups:concurrency'), `${groupId}`);
    }
    /**
     * Gets group concurrency.
     *
     * @param groupId -
     */
    async getGroupConcurrency(groupId) {
        const client = await this.client;
        const concurrency = await client.hget(this.toKey('groups:concurrency'), `${groupId}`);
        return parseInt(concurrency || '0');
    }
    /**
     * Cleans all the jobs that are part of a group.
     *
     * @param groupId -
     */
    async deleteGroup(groupId) {
        while ((await this.scripts.deleteGroup(groupId)) > 0) {
            // Empty
        }
    }
    /**
     * Cleans all the groups in this queue
     *
     * @param groupId -
     */
    async deleteGroups() {
        while (!(await this.scripts.deleteGroups())) {
            // Empty
        }
    }
    /**
     * Returns the time to live for a rate limited key in milliseconds.
     * @param groupId - group identifier
     * @param maxJobs - max jobs to be considered in rate limit state. If not passed
     * it will return the remaining ttl without considering if max jobs is excedeed.
     * @returns -2 if the key does not exist.
     * -1 if the key exists but has no associated expire.
     * @see {@link https://redis.io/commands/pttl/}
     */
    async getGroupRateLimitTtl(groupId, maxJobs) {
        return this.scripts.getGroupRateLimitTtl(groupId, maxJobs);
    }
    async obliterate(opts) {
        await this.deleteGroups();
        return super.obliterate(opts);
    }
    /**
     * Pauses the processing of a specific group globally.
     *
     * Adding jobs requires a LUA script to check first if the paused list exist
     * and in that case it will add it there instead of the wait list or group list.
     */
    async pauseGroup(groupId) {
        return this.scripts.pauseGroup(groupId, true);
    }
    /**
     * Resumes the processing of a specific group globally.
     *
     * The method reverses the pause operation by resuming the processing of the
     * group.
     *
     * @param groupId - the group to resume
     */
    async resumeGroup(groupId) {
        return this.scripts.pauseGroup(groupId, false);
    }
    /**
     * Repairs a maxed group.
     *
     * It seems that in some unknown situations a group can become maxed although there
     * are no active jobs in the group. This function will try to repair this situation.
     *
     * @param groupId - the group to repair
     * @param concurrency - maximum number of simultaneous jobs that the workers can handle within a specific group
     */
    async repairMaxedGroup(groupId, concurrency) {
        return this.scripts.repairMaxedGroup(groupId, concurrency);
    }
    /**
     * Repairs stalled key when you are migrating from v4 or below to v6 or above.
     * This key used a zset and now it uses a set, this is why this method is needed.
     * An error like: 'WRONGTYPE Operation against a key holding the wrong kind of
     * value' in moveStalledJobsToWait script is a good indicator of this change.
     * Note: Migration from v5 to v6 won't need to call this method
     */
    repairStalledKey() {
        return this.scripts.repairStalledKey();
    }
}
exports.QueuePro = QueuePro;
//# sourceMappingURL=queue-pro.js.map