"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.moveToDelayed = void 0;
const content = `--[[
  Moves job from active to delayed set.
  Input:
    KEYS[1] marker key
    KEYS[2] active key
    KEYS[3] prioritized key
    KEYS[4] delayed key
    KEYS[5] job key
    KEYS[6] events stream
    KEYS[7] meta key
    KEYS[8] stalled key
    ARGV[1] key prefix
    ARGV[2] timestamp
    ARGV[3] the id of the job
    ARGV[4] queue token
    ARGV[5] delay
    ARGV[6] concurrency
    ARGV[7] skip attempt
    ARGV[8] optional job fields to update
  Output:
    0 - OK
   -1 - Missing job.
   -2 - Missing lock
   -3 - Job not in active set.
  Events:
    - delayed key.
]]
local rcall = redis.call
-- Includes
--[[
  Add delay marker if needed.
]]
-- Includes
--[[
  Function to return the next delayed job timestamp.
]]
local function getNextDelayedTimestamp(delayedKey)
  local result = rcall("ZRANGE", delayedKey, 0, 0, "WITHSCORES")
  if #result then
    local nextTimestamp = tonumber(result[2])
    if nextTimestamp ~= nil then 
      return nextTimestamp / 0x1000
    end
  end
end
local function addDelayMarkerIfNeeded(markerKey, delayedKey)
  local nextTimestamp = getNextDelayedTimestamp(delayedKey)
  if nextTimestamp ~= nil then
    -- Replace the score of the marker with the newest known
    -- next timestamp.
    rcall("ZADD", markerKey, nextTimestamp, "1")
  end
end
--[[
  Bake in the job id first 12 bits into the timestamp
  to guarantee correct execution order of delayed jobs
  (up to 4096 jobs per given timestamp or 4096 jobs apart per timestamp)
  WARNING: Jobs that are so far apart that they wrap around will cause FIFO to fail
]]
local function getDelayedScore(delayedKey, timestamp, delay)
  local delayedTimestamp = (delay > 0 and (tonumber(timestamp) + delay)) or tonumber(timestamp)
  local minScore = delayedTimestamp * 0x1000
  local maxScore = (delayedTimestamp + 1 ) * 0x1000 - 1
  local result = rcall("ZREVRANGEBYSCORE", delayedKey, maxScore,
    minScore, "WITHSCORES","LIMIT", 0, 1)
  if #result then
    local currentMaxScore = tonumber(result[2])
    if currentMaxScore ~= nil then
      if currentMaxScore >= maxScore then
        return maxScore, delayedTimestamp
      else
        return currentMaxScore + 1, delayedTimestamp
      end
    end
  end
  return minScore, delayedTimestamp
end
--[[
  Function to get max events value or set by default 10000.
]]
local function getOrSetMaxEvents(metaKey)
    local maxEvents = rcall("HGET", metaKey, "opts.maxLenEvents")
    if not maxEvents then
        maxEvents = 10000
        rcall("HSET", metaKey, "opts.maxLenEvents", maxEvents)
    end
    return maxEvents
end
--[[
  Function to check for the meta.paused key to decide if we are paused or not
  (since an empty list and !EXISTS are not really the same).
]]
local function isQueuePaused(queueMetaKey)
  return rcall("HEXISTS", queueMetaKey, "paused") == 1
end
local function removeLock(jobKey, stalledKey, token, jobId)
  if token ~= "0" then
    local lockKey = jobKey .. ':lock'
    local lockToken = rcall("GET", lockKey)
    if lockToken == token then
      rcall("DEL", lockKey)
      rcall("SREM", stalledKey, jobId)
    else
      if lockToken then
        -- Lock exists but token does not match
        return -6
      else
        -- Lock is missing completely
        return -2
      end
    end
  end
  return 0
end
--[[
  Function to update a bunch of fields in a job.
]]
local function updateJobFields(jobKey, msgpackedFields)
    if msgpackedFields and #msgpackedFields > 0 then
        local fieldsToUpdate = cmsgpack.unpack(msgpackedFields)
        if fieldsToUpdate then
            redis.call("HMSET", jobKey, unpack(fieldsToUpdate))
        end
    end
end
--[[
  Function to decrease group concurrency.
  Returns true if group is removed from maxed.
]]
-- Includes
--[[
  Promote a maxed group (if any) so that it is not maxed anymore
]]
-- Includes
--[[
  Add marker if needed when a job is available.
]]
local function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)
  if not isPausedOrMaxed then
    rcall("ZADD", markerKey, 0, "0")
  end  
end
-- Includes
local function isGroupRateLimited(groupKey)
  local groupRateLimitKey = groupKey .. ':limit'
  local jobCounter = tonumber(rcall("GET", groupRateLimitKey))
  return jobCounter and jobCounter >= 999999
end
--[[
  Reinsert the group with the highest score so that it is moved to the last position
]]
local function reinsertGroupIfNeeded(groupKey, groupsKey, groupId)
  if rcall("LLEN", groupKey) > 0 or rcall("ZCARD", groupKey .. ":p") > 0 then
    local highscore = rcall("ZREVRANGE", groupsKey, 0, 0, "withscores")[2] or 0
    -- Note, this mechanism could keep increasing the score indefinetely.
    -- Score can represent 2^53 integers, so approximatelly 285 years adding 1M jobs/second
    -- before it starts misbehaving.
    rcall("ZADD", groupsKey, highscore + 1, groupId)
    return true
  else
    rcall("HDEL", groupsKey .. ":pc", groupId)
    return false
  end
end
local function reinsertGroupIfNotRateLimitedOrPaused(prefixKey, groupId)
  if rcall("ZSCORE", prefixKey .. "groups:paused", groupId) == false then
    local groupKey = prefixKey .. 'groups:' .. groupId
    if not isGroupRateLimited(groupKey) then
      local groupsKey = prefixKey .. 'groups'
      return reinsertGroupIfNeeded(groupKey, groupsKey, groupId)
    end
  end
end
local function promoteMaxedGroup(prefixKey, markerKey, paused, groupId)
    if rcall("ZREM", prefixKey .. "groups:max", groupId) > 0 then
        local groupsKey = prefixKey .. 'groups'
        if reinsertGroupIfNotRateLimitedOrPaused(prefixKey, groupId) then
            addBaseMarkerIfNeeded(markerKey, paused)
        end
    end
end
local function isGroupMaxed(prefixKey, groupId)
  return rcall("ZSCORE", prefixKey .. "groups:max", groupId) ~= false
end
local function decreaseGroupConcurrency(prefixKey, markerKey, paused, groupId, maxConcurrency)
    local activeCountKey = prefixKey .. "groups:active:count"
    local activeCount = rcall("HGET", activeCountKey, groupId)
    if activeCount then
        local count = rcall("HINCRBY", activeCountKey, groupId, -1)
        if count <= 0 then rcall("HDEL", activeCountKey, groupId) end
        local localConcurrency = rcall("HGET", prefixKey .. "groups:concurrency", groupId)
        -- We use maxConcurrency, in case the user decides to change it (lower it),
        -- we need to check it here so that we keep the group in active if necessary.
        if count < tonumber(localConcurrency or maxConcurrency) and
            isGroupMaxed(prefixKey, groupId) then
            promoteMaxedGroup(prefixKey, markerKey, paused, groupId)
            return true
        end
    end
    return false
end
local markerKey = KEYS[1]
local jobKey = KEYS[5]
local metaKey = KEYS[7]
local token = ARGV[4]
if rcall("EXISTS", jobKey) == 1 then
  local errorCode = removeLock(jobKey, KEYS[8], token, ARGV[3])
  if errorCode < 0 then
    return errorCode
  end
  updateJobFields(jobKey, ARGV[8])
  local delayedKey = KEYS[4]
  local jobId = ARGV[3]
  local delay = tonumber(ARGV[5])
  local score, delayedTimestamp = getDelayedScore(delayedKey, ARGV[2], delay)
  local numRemovedElements = rcall("LREM", KEYS[2], -1, jobId)
  if(numRemovedElements < 1) then return -3 end
  local isPaused = isQueuePaused(metaKey)
  local groupId = rcall("HGET", jobKey, "gid")
  if groupId then
    decreaseGroupConcurrency(ARGV[1], markerKey, isPaused, groupId,
      tonumber(ARGV[6] or 999999))
  end
  if ARGV[7] == "0" then
    rcall("HINCRBY", jobKey, "atm", 1)
  end
  rcall("HSET", jobKey, "delay", ARGV[5])
  local maxEvents = getOrSetMaxEvents(metaKey)
  rcall("ZADD", delayedKey, score, jobId)
  rcall("XADD", KEYS[6], "MAXLEN", "~", maxEvents, "*", "event", "delayed",
    "jobId", jobId, "delay", delayedTimestamp);
  addDelayMarkerIfNeeded(markerKey, delayedKey)
  return 0
else
  return -1
end
`;
exports.moveToDelayed = {
    name: 'moveToDelayed',
    content,
    keys: 8,
};
//# sourceMappingURL=moveToDelayed-8.js.map