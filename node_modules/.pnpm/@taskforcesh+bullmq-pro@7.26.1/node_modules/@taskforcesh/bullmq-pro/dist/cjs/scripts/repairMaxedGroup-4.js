"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.repairMaxedGroup = void 0;
const content = `--[[
   Try to repair broken maxed groups.
   Input:
      KEYS[1]  active count key ("groups:active:count")
      KEYS[2]  groups max key ("groups:max")
      KEYS[3]  active key -- redis list of active jobs
      KEYS[4]  groups waiting key ("groups")
      ARGV[1] groupId
      ARGV[2] prefix
      ARGV[3] group concurrency
]]
local rcall = redis.call
local function reAddGroup(groupsKey, groupsMaxConcurrencyKey, groupId)
    -- we assume the group should not be maxed, so we remove it from the maxed
    -- groups set.
    rcall("ZREM", groupsMaxConcurrencyKey, groupId)
    -- And add it to the waiting groups set.
    rcall("ZADD", groupsKey, 0, groupId)
end
-- Count all the active jobs that belong to the give group.
local activeCount = 0
local activeJobs = rcall("LRANGE", KEYS[3], 0, -1)
for _, jobId in ipairs(activeJobs) do
    local groupId = rcall("HGET", ARGV[2] .. jobId, "gid")
    if groupId == ARGV[1] then activeCount = activeCount + 1 end
end
-- If the active count does not match the stored active count for a group
-- we need to repair the group.
local activeCountKey = KEYS[1]
local expectedActiveCount = tonumber(rcall("HGET", activeCountKey, ARGV[1]) or 0)
local maxGroupConcurrency = tonumber(ARGV[3])
if activeCount == expectedActiveCount and activeCount >= maxGroupConcurrency then return end
rcall("HSET", activeCountKey, ARGV[1], activeCount)
if maxGroupConcurrency > 0 then
    if activeCount > maxGroupConcurrency then return end
    if activeCount < maxGroupConcurrency then
        reAddGroup(KEYS[4], KEYS[2], ARGV[1])
    end
else
    if activeCount > expectedActiveCount then return end
    if activeCount < expectedActiveCount then
        reAddGroup(KEYS[4], KEYS[2], ARGV[1])
    end
end
`;
exports.repairMaxedGroup = {
    name: 'repairMaxedGroup',
    content,
    keys: 4,
};
//# sourceMappingURL=repairMaxedGroup-4.js.map