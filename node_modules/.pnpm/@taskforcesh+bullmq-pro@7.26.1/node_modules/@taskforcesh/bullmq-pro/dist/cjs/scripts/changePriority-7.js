"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.changePriority = void 0;
const content = `--[[
  Change job priority
  Input:
    KEYS[1] 'wait',
    KEYS[2] 'paused'
    KEYS[3] 'meta'
    KEYS[4] 'prioritized'
    KEYS[5] 'active'
    KEYS[6] 'pc' priority counter
    KEYS[7] 'marker'
    ARGV[1] priority value
    ARGV[2] prefix key
    ARGV[3] job id
    ARGV[4] lifo
    Output:
       0  - OK
      -1  - Missing job
]]
local jobId = ARGV[3]
local jobKey = ARGV[2] .. jobId
local priority = tonumber(ARGV[1])
local rcall = redis.call
-- Includes
--[[
  Function to add job in target list and add marker if needed.
]]
-- Includes
--[[
  Add marker if needed when a job is available.
]]
local function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)
  if not isPausedOrMaxed then
    rcall("ZADD", markerKey, 0, "0")
  end  
end
local function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)
  rcall(pushCmd, targetKey, jobId)
  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)
end
--[[
  Function to check for the meta.paused key to decide if we are paused or not
  (since an empty list and !EXISTS are not really the same).
]]
local function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)
  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")
  if queueAttributes[1] then
    return pausedKey, true
  else
    if queueAttributes[2] then
      local activeCount = rcall("LLEN", activeKey)
      if activeCount >= tonumber(queueAttributes[2]) then
        return waitKey, true
      else
        return waitKey, false
      end
    end
  end
  return waitKey, false
end
--[[
  Function to push back job considering priority in front of same prioritized jobs.
]]
local function pushBackJobWithPriority(prioritizedKey, priority, jobId)
  -- in order to put it at front of same prioritized jobs
  -- we consider prioritized counter as 0
  local score = priority * 0x100000000
  rcall("ZADD", prioritizedKey, score, jobId)
end
--[[
  Function to add job considering priority.
]]
-- Includes
local function addJobWithPriority(markerKey, prioritizedKey, priority, jobId,
    priorityCounterKey, isPausedOrMaxed, groupId)
  local prioCounter
  if groupId then
    prioCounter = rcall("HINCRBY", priorityCounterKey, groupId, 1)
  else
    prioCounter = rcall("INCR", priorityCounterKey)
  end
  local score = priority * 0x100000000 + prioCounter % 0x100000000
  rcall("ZADD", prioritizedKey, score, jobId)
  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)
end
local function reAddJobWithNewPriority( prioritizedKey, markerKey, targetKey,
    priorityCounter, lifo, priority, jobId, isPausedOrMaxed, groupId)
    if priority == 0 then
        local pushCmd = lifo and 'RPUSH' or 'LPUSH'
        addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)
    else
        if lifo then
            pushBackJobWithPriority(prioritizedKey, priority, jobId)
        else
            addJobWithPriority(markerKey, prioritizedKey, priority, jobId,
                priorityCounter, isPausedOrMaxed, groupId)
        end
    end
end
if rcall("EXISTS", jobKey) == 1 then
    local metaKey = KEYS[3]
    local target, isPausedOrMaxed = getTargetQueueList(metaKey, KEYS[5], KEYS[1], KEYS[2])
    local prioritizedKey = KEYS[4]
    local priorityCounterKey = KEYS[6]
    local markerKey = KEYS[7]
    local groupId = rcall("HGET", jobKey, "gid")
    if groupId then
        local groupKey = ARGV[2] .. 'groups:' .. groupId
        local groupPrioritizedKey = groupKey .. ":p"
        -- Re-add with the new priority
        if rcall("ZREM", groupPrioritizedKey, jobId) > 0 then
            reAddJobWithNewPriority( groupPrioritizedKey, markerKey, groupKey,
                priorityCounterKey, ARGV[4] == '1', priority, jobId, false, groupId)
        elseif rcall("LREM", groupKey, -1, jobId) > 0 then
            reAddJobWithNewPriority( groupPrioritizedKey, markerKey, groupKey,
                priorityCounterKey, ARGV[4] == '1', priority, jobId, false, groupId)
        end
    else
        -- Re-add with the new priority
        if rcall("ZREM", KEYS[4], jobId) > 0 then
            reAddJobWithNewPriority( prioritizedKey, markerKey, target,
                priorityCounterKey, ARGV[4] == '1', priority, jobId, isPausedOrMaxed, nil)
        elseif rcall("LREM", target, -1, jobId) > 0 then
            reAddJobWithNewPriority( prioritizedKey, markerKey, target,
                priorityCounterKey, ARGV[4] == '1', priority, jobId, isPausedOrMaxed, nil)
        end
    end
    rcall("HSET", jobKey, "priority", priority)
    return 0
else
    return -1
end
`;
exports.changePriority = {
    name: 'changePriority',
    content,
    keys: 7,
};
//# sourceMappingURL=changePriority-7.js.map