import { Worker, SpanKind, TelemetryAttributes, } from 'bullmq';
import { isObservable, from } from 'rxjs';
import { last, switchMap, timeout } from 'rxjs/operators';
import { RedisConnectionPro } from './redis-connection-pro';
import { JobPro } from './job-pro';
import { ScriptsPro } from '../classes/scripts-pro';
/**
 * @see {@link bullmq!Worker | Worker}
 */
export class WorkerPro extends Worker {
    constructor(name, processor, opts) {
        var _a, _b;
        super(name, processor, Object.assign(Object.assign({}, opts), { autorun: false }), RedisConnectionPro);
        if (((_a = opts === null || opts === void 0 ? void 0 : opts.group) === null || _a === void 0 ? void 0 : _a.limit) && ((_b = opts === null || opts === void 0 ? void 0 : opts.group) === null || _b === void 0 ? void 0 : _b.concurrency)) {
            throw new Error('Rate limit and concurrency cannot be used together');
        }
        const ttlType = typeof (opts === null || opts === void 0 ? void 0 : opts.ttl);
        if (opts && ttlType !== 'undefined') {
            const ttlError = new Error('Ttl must be a positive number');
            if (ttlType == 'number' && opts.ttl <= 0) {
                throw ttlError;
            }
            else {
                for (const ttl of Object.values(opts.ttl)) {
                    if (ttl <= 0) {
                        throw ttlError;
                    }
                }
            }
        }
        if (processor) {
            if (!opts || typeof opts.autorun === 'undefined' ? true : opts.autorun) {
                this.run().catch(error => this.emit('error', error));
            }
        }
    }
    emit(event, ...args) {
        return super.emit(event, ...args);
    }
    off(eventName, listener) {
        super.off(eventName, listener);
        return this;
    }
    on(event, listener) {
        super.on(event, listener);
        return this;
    }
    once(event, listener) {
        super.once(event, listener);
        return this;
    }
    setScripts() {
        this.scripts = new ScriptsPro(this);
    }
    get Job() {
        return JobPro;
    }
    async callProcessJob(job, token) {
        var _a;
        const result = await this.processFn(job, token);
        if (isObservable(result)) {
            const observable = result;
            const pipe = [
                switchMap((value) => from(this.storeResult(job.id, token, value))),
                last(),
            ];
            if (this.opts.ttl) {
                const ttl = typeof this.opts.ttl === 'number'
                    ? this.opts.ttl
                    : (_a = this.opts) === null || _a === void 0 ? void 0 : _a.ttl[job.name];
                pipe.push(timeout(ttl));
            }
            return (observable.pipe.apply(observable, pipe).toPromise());
        }
        else {
            return result;
        }
    }
    /**
     * Store returnValue.
     *
     * @param jobId - Job identifier.
     * @param token - Token lock.
     * @param returnValue - The jobs success message.
     */
    async storeResult(jobId, token, returnValue) {
        await this.scripts.storeResult(jobId, token, returnValue);
        return returnValue;
    }
    async nextJobFromJobData(jobData, jobId, token) {
        if (jobData && Array.isArray(jobData)) {
            const jobs = [];
            const jobsData = jobData;
            const jobIds = jobId;
            return this.trace(SpanKind.PRODUCER, 'process.batch', this.name, async (span, targetMetadata) => {
                var _a, _b;
                span === null || span === void 0 ? void 0 : span.setAttribute(TelemetryAttributes.BulkCount, jobs.length);
                for (let i = 0; i < jobsData.length; i++) {
                    const job = JobPro.fromJSON(this, jobsData[i], jobIds[i]);
                    const telemetryMetadata = (_b = (_a = job.opts) === null || _a === void 0 ? void 0 : _a.telemetry) === null || _b === void 0 ? void 0 : _b.metadata;
                    this.trace(SpanKind.CONSUMER, 'process.batched', this.name, async (span) => {
                        span === null || span === void 0 ? void 0 : span.setAttributes({
                            [TelemetryAttributes.JobId]: job.id,
                            [TelemetryAttributes.JobName]: job.name,
                        });
                        job.token = token;
                        jobs.push(job);
                        if (job.opts.repeat) {
                            const repeat = await this.repeat;
                            await repeat.updateRepeatableJob(job.name, job.data, job.opts, {
                                override: false,
                            });
                        }
                    }, telemetryMetadata);
                }
                const batchJob = {
                    id: jobIds.join(','),
                    name: 'batch',
                    data: '',
                    delay: 0,
                    progress: 0,
                };
                const job = await super.nextJobFromJobData(batchJob, jobId, token);
                const jobPro = JobPro.fromJob(this, job);
                jobPro.setBatch(jobs);
                jobPro.token = token;
                jobPro.opts.telemetry = Object.assign(Object.assign({}, jobPro.opts.telemetry), { metadata: targetMetadata });
                return jobPro;
            });
        }
        else {
            return (await super.nextJobFromJobData(jobData, jobId, token));
        }
    }
    /**
     * Overrides the rate limit so that it becomes active for the given group.
     *
     * @param job - Job currently being processed, and whose group we want to rate limit.
     * @param expireTimeMs - Expire time in ms of this rate limit.
     */
    async rateLimitGroup(job, expireTimeMs) {
        var _a;
        const opts = job.opts;
        const groupId = (_a = opts.group) === null || _a === void 0 ? void 0 : _a.id;
        if (typeof groupId === 'undefined') {
            throw new Error('Job must have a group id');
        }
        if (expireTimeMs <= 0) {
            throw new Error('expireTimeMs must be greater than 0');
        }
        return this.scripts.rateLimitGroup(groupId, expireTimeMs);
    }
    async extendLocks(jobs) {
        try {
            const multi = (await this.client).multi();
            for (const job of jobs) {
                const batch = job.getBatch();
                if (batch && batch.length > 0) {
                    for (const batchJob of batch) {
                        await this.scripts.extendLock(batchJob.id, batchJob.token, this.opts.lockDuration, multi);
                    }
                }
                else {
                    await this.scripts.extendLock(job.id, job.token, this.opts.lockDuration, multi);
                }
            }
            const result = (await multi.exec());
            for (const [err, jobId] of result) {
                if (err) {
                    // TODO: signal process function that the job has been lost.
                    this.emit('error', new Error(`could not renew lock for job ${jobId}`));
                }
            }
        }
        catch (err) {
            this.emit('error', err);
        }
    }
}
WorkerPro.RateLimitError = Worker.RateLimitError;
//# sourceMappingURL=worker-pro.js.map