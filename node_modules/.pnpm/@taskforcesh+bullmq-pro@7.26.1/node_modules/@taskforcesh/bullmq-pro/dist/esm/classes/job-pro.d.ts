import { Job, MinimalQueue } from 'bullmq';
import { ScriptsPro } from '../classes/scripts-pro';
import { JobProJson, JobProJsonRaw, JobsProOptions } from '../interfaces';
import { JobProJsonSandbox } from '../types';
/**
 * @see {@link bullmq!Job | Job}
 */
export declare class JobPro<DataType = any, ReturnType = any, NameType extends string = string> extends Job<DataType, ReturnType, NameType> {
    protected queue: MinimalQueue;
    id?: string;
    gid: string | number;
    opts: JobsProOptions;
    private batch?;
    private failedError?;
    protected scripts: ScriptsPro;
    constructor(queue: MinimalQueue, 
    /**
     * The name of the Job
     */
    name: NameType, 
    /**
     * The payload for this job.
     */
    data: DataType, 
    /**
     * The options object for this job.
     */
    opts?: JobsProOptions, id?: string);
    protected setScripts(): void;
    /**
     * Instantiates a JobPro instance based on a standard Job instance.
     * @param job -
     */
    static fromJob<DataType = any, ResultType = any, NameType extends string = string>(queue: MinimalQueue, job: Job): JobPro<DataType, ResultType, NameType>;
    /**
     * Instantiates a Job from a JobJsonRaw object (coming from a deserialized JSON object)
     *
     * @param queue - the queue where the job belongs to.
     * @param json - the plain object containing the job.
     * @param jobId - an optional job id (overrides the id coming from the JSON object)
     * @returns
     */
    static fromJSON<T = any, R = any, N extends string = string>(queue: MinimalQueue, json: JobProJsonRaw, jobId?: string): JobPro<T, R, N>;
    protected validateOptions(jobData: JobProJson): void;
    /**
     * Prepares a job to be passed to Sandbox.
     * @returns
     */
    asJSONSandbox(): JobProJsonSandbox;
    /**
     * Moves a job to the completed queue.
     * Returned job to be used with Queue.prototype.nextJobFromJobData.
     *
     * @param returnValue - The jobs success message.
     * @param token - Worker token used to acquire completed job.
     * @param fetchNext - True when wanting to fetch the next job.
     * @returns Returns the jobData of the next job in the waiting queue.
     */
    moveToCompleted(returnValue: ReturnType, token: string, fetchNext?: boolean): Promise<void | any[]>;
    /**
     * Moves a batch of jobs to the complete set.
     * @param batch -
     * @returns The next batch of jobs if any wrapped in a batch job.
     */
    private moveBatchToCompleted;
    /**
     * Moves a batch of jobs to the failed set.
     * @param err -
     * @param token -
     * @param batch -
     */
    private moveBatchToFailed;
    /**
     * Moves a job to the failed queue.
     *
     * @param err - the jobs error message.
     * @param token - token to check job is locked by current worker
     * @param fetchNext - true when wanting to fetch the next job
     * @returns void
     */
    moveToFailed(err: Error, token: string, fetchNext?: boolean): Promise<void | any[]>;
    /**
     * Sets a batch of jobs for this job.
     *
     */
    setBatch(jobs: JobPro[]): void;
    /**
     * Returns the batch of jobs for this job if any.
     *
     * @returns
     * @see {@link bullmq!Job | Job}
     * @see {@link bullmq!JobPro | JobPro}
     *
     * @example
     * ```typescript
     *
     *
     * ```
     */
    getBatch(): JobPro<any, any, string>[];
    /**
     * Set job as failed. This method will set the current job instance as failed,
     * it is useful when processing batches to mark a certain job in a batch as failed
     * while completing the rest.
     * @param err - The error object to be associated with the job.
     */
    setAsFailed(err: Error): void;
    extendLock(token: string, duration: number): Promise<number>;
}
