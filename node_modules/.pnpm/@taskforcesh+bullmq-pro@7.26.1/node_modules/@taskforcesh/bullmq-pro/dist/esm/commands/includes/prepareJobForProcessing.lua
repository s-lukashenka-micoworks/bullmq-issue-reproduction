-- Includes
--- @include "<base>/includes/addBaseMarkerIfNeeded"

local function prepareJobForProcessing(keyPrefix, rateLimiterKey,
                                       eventStreamKey, jobId, processedOn,
                                       maxJobs, markerKey, options, rateLimitedNextTtl)
    local token = options['token']
    local lockDuration = options['lockDuration']
    local jobKey = keyPrefix .. jobId
    if maxJobs then
        -- Check if we need to perform global rate limiting
        local jobCounter = tonumber(rcall("INCR", rateLimiterKey))

        if jobCounter == 1 then
            local limiterDuration = options['limiter'] and
                                        options['limiter']['duration']
            local integerDuration = math.floor(math.abs(limiterDuration))
            rcall("PEXPIRE", rateLimiterKey, integerDuration)
        end
    end

    local lockKey = jobKey .. ':lock'

    rcall("SET", lockKey, token, "PX", lockDuration)

    local optionalValues = {}

    if options['name'] then
        -- Set "processedBy" field to the worker name
        table.insert(optionalValues, "pb")
        table.insert(optionalValues, opts['name'])
    end

    rcall("XADD", eventStreamKey, "*", "event", "active", "jobId", jobId,
          "prev", "waiting")

    rcall("HMSET", jobKey, "processedOn", processedOn, unpack(optionalValues))
    rcall("HINCRBY", jobKey, "ats", 1)
    -- This is a bit wrong actually, the queue could have jobs that are ratelimited or
    -- have reached max concurrency, so in that case we should not emit this.

    addBaseMarkerIfNeeded(markerKey, false)

    return {rcall("HGETALL", jobKey), jobId, 0, rateLimitedNextTtl or 0} -- get job data
end
