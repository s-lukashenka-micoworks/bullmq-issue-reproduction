const content = `--[[
  Pauses or resumes a group globably.
   Input:
      KEYS[1]  wait key
      KEYS[2]  group key
      KEYS[3]  groups key
      KEYS[4]  paused groups key
      KEYS[5]  group rate limit key
      KEYS[6]  groups rate limit key
      KEYS[7]  groups max key
      KEYS[8]  marker key
      KEYS[9]  meta key
      KEYS[10] paused key
      KEYS[11] active key
      KEYS[12] events stream key
      ARGV[1] groupId
      ARGV[2] '1' resume or '0' pause
      ARGV[3] timestamp
    Event:
      publish paused or resumed event.
]]
local rcall = redis.call
-- Includes
--[[
  Add marker if needed when a job is available.
]]
local function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)
  if not isPausedOrMaxed then
    rcall("ZADD", markerKey, 0, "0")
  end  
end
--[[
  Function to check for the meta.paused key to decide if we are paused or not
  (since an empty list and !EXISTS are not really the same).
]]
local function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)
  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")
  if queueAttributes[1] then
    return pausedKey, true
  else
    if queueAttributes[2] then
      local activeCount = rcall("LLEN", activeKey)
      if activeCount >= tonumber(queueAttributes[2]) then
        return waitKey, true
      else
        return waitKey, false
      end
    end
  end
  return waitKey, false
end
--[[
  Reinsert the group with the highest score so that it is moved to the last position
]]
local function reinsertGroupIfNeeded(groupKey, groupsKey, groupId)
  if rcall("LLEN", groupKey) > 0 or rcall("ZCARD", groupKey .. ":p") > 0 then
    local highscore = rcall("ZREVRANGE", groupsKey, 0, 0, "withscores")[2] or 0
    -- Note, this mechanism could keep increasing the score indefinetely.
    -- Score can represent 2^53 integers, so approximatelly 285 years adding 1M jobs/second
    -- before it starts misbehaving.
    rcall("ZADD", groupsKey, highscore + 1, groupId)
    return true
  else
    rcall("HDEL", groupsKey .. ":pc", groupId)
    return false
  end
end
if ARGV[2] == '1' then
  if rcall("ZREM", KEYS[4], ARGV[1]) == 1 then
    -- Is group rate limited?
    local jobCounter = tonumber(rcall("GET", KEYS[5]))
    local isRateLimited = jobCounter and jobCounter >= 999999
    if not isRateLimited and rcall("ZSCORE", KEYS[7], ARGV[1]) == false then
      rcall("ZREM", KEYS[6], ARGV[1])
      local target, isPausedOrMaxed = getTargetQueueList(KEYS[9], KEYS[11], KEYS[1], KEYS[10])
      reinsertGroupIfNeeded(KEYS[2], KEYS[3], ARGV[1])
      addBaseMarkerIfNeeded(KEYS[8], isPausedOrMaxed)
    end
    rcall("XADD", KEYS[12], "*", "event", "groups:resumed", "groupId", ARGV[1]);
    return 0
  end
  return 1
end
if ARGV[2] == '0' then
  if rcall("ZADD", KEYS[4], ARGV[3], ARGV[1]) == 0 then
    return 1
  end
  if rcall("ZREM", KEYS[3], ARGV[1]) == 1 then
    rcall("XADD", KEYS[12], "*", "event", "groups:paused", "groupId", ARGV[1]);
  end
  return 0
end
`;
export const pauseGroup = {
    name: 'pauseGroup',
    content,
    keys: 12,
};
//# sourceMappingURL=pauseGroup-12.js.map