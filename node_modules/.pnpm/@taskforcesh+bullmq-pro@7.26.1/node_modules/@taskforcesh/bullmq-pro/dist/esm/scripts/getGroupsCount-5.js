const content = `--[[
  Get jobs count belonging to all groups. Since there could be thousands of
  groups, this call can be made iteratively.
  Input:
      KEYS[1] key prefix
      KEYS[2] groups key
      KEYS[3] groups limit key
      KEYS[4] groups max key
      KEYS[5] groups paused key
      -- Arguments
      ARGV[1] start
      ARGV[2] end
      ARGV[3] current group state
]]
local rcall = redis.call
--[[
  Get count jobs belonging to a given group.
]]
local function getGroupCount(groupId, prefixKey)
  local groupKey = prefixKey .. 'groups:' .. groupId
  local nonPrioritizedGroupSize = rcall("LLEN", groupKey)
  local prioritizedGroupSize = rcall("ZCARD", groupKey .. ":p")
  return nonPrioritizedGroupSize + prioritizedGroupSize
end
local function getGroupsCountPerStatus(prefixKey, groupsKey, stateKey, startIndex, endIndex)
    local currentCount = 0
    local groupIds = rcall("ZRANGE", stateKey, startIndex, endIndex);
    if #groupIds > 0 then
        for i, groupId in ipairs(groupIds) do
            local groupKey = groupsKey .. ":" .. groupId
            currentCount = currentCount + getGroupCount(groupId, prefixKey)
        end
    end
    return currentCount, #groupIds
end
local count = 0
local startIndex = tonumber(ARGV[1])
local endIndex = tonumber(ARGV[2])
local currentState = ARGV[3]
-- waiting state
if currentState == "waiting" then
    local waitingJobsCount, waitingGroupCount = getGroupsCountPerStatus(KEYS[1], KEYS[2], KEYS[2], startIndex, endIndex)
    if waitingGroupCount == endIndex + 1 then
        return { count + waitingJobsCount, "waiting", endIndex + 1 }
    else
        count = count + waitingJobsCount
        startIndex = 0
        endIndex = endIndex - waitingGroupCount
        currentState = "limited"
    end
end
-- limited state
if currentState == "limited" then
    local limitedJobsCount, limitedGroupCount = getGroupsCountPerStatus(KEYS[1], KEYS[2], KEYS[3], startIndex, endIndex)
    if limitedGroupCount == endIndex + 1 then
        return { count + limitedJobsCount, "limited", endIndex + 1 }
    else
        count = count + limitedJobsCount
        startIndex = 0
        endIndex = endIndex - limitedGroupCount
        currentState = "maxed"
    end
end
-- maxed state
if currentState == "maxed" then
    local maxedJobsCount, maxedGroupCount = getGroupsCountPerStatus(KEYS[1], KEYS[2], KEYS[4], startIndex, endIndex)
    if maxedGroupCount == endIndex + 1 then
        return { count + maxedJobsCount, "maxed", endIndex + 1 }
    else
        count = count + maxedJobsCount
        startIndex = 0
        endIndex = endIndex - maxedGroupCount
        currentState = "paused"
    end
end
-- paused state
if currentState == "paused" then
    local pausedJobsCount, pausedGroupCount = getGroupsCountPerStatus(KEYS[1], KEYS[2], KEYS[5], startIndex, endIndex)
    if pausedGroupCount == endIndex + 1 then
        return { count + pausedJobsCount, "paused", endIndex + 1 }
    else
        return { count + pausedJobsCount, nil, nil }
    end
end
`;
export const getGroupsCount = {
    name: 'getGroupsCount',
    content,
    keys: 5,
};
//# sourceMappingURL=getGroupsCount-5.js.map