const content = `--[[
  Delete jobs belonging to a given group.
  Input:
    ARGV[1] key prefix
    KEYS[2] groupsKey
    -- Arguments
    ARGV[1] limit amount of jobs to delete
]]
local rcall = redis.call
-- Includes
--[[
  Delete all groups and their jobs up to the given limit.
  Returns true when all groups have been deleted.
]]
-- Includes
--[[
  Function to remove job.
]]
-- Includes
--[[
  Function to remove deduplication key.
]]
local function removeDeduplicationKey(prefixKey, jobKey)
  local deduplicationId = rcall("HGET", jobKey, "deid")
  if deduplicationId then
    local deduplicationKey = prefixKey .. "de:" .. deduplicationId
    rcall("DEL", deduplicationKey)
  end
end
--[[
  Function to remove job keys.
]]
local function removeJobKeys(jobKey)
  return rcall("DEL", jobKey, jobKey .. ':logs',
    jobKey .. ':dependencies', jobKey .. ':processed', jobKey .. ':failed')
end
--[[
  Check if this job has a parent. If so we will just remove it from
  the parent child list, but if it is the last child we should move the parent to "wait/paused"
  which requires code from "moveToFinished"
]]
-- Includes
--[[
  Function to add job in target list and add marker if needed.
]]
-- Includes
--[[
  Add marker if needed when a job is available.
]]
local function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)
  if not isPausedOrMaxed then
    rcall("ZADD", markerKey, 0, "0")
  end  
end
local function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)
  rcall(pushCmd, targetKey, jobId)
  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)
end
--[[
  Functions to destructure job key.
  Just a bit of warning, these functions may be a bit slow and affect performance significantly.
]]
local getJobIdFromKey = function (jobKey)
  return string.match(jobKey, ".*:(.*)")
end
local getJobKeyPrefix = function (jobKey, jobId)
  return string.sub(jobKey, 0, #jobKey - #jobId)
end
--[[
  Function to check for the meta.paused key to decide if we are paused or not
  (since an empty list and !EXISTS are not really the same).
]]
local function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)
  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")
  if queueAttributes[1] then
    return pausedKey, true
  else
    if queueAttributes[2] then
      local activeCount = rcall("LLEN", activeKey)
      if activeCount >= tonumber(queueAttributes[2]) then
        return waitKey, true
      else
        return waitKey, false
      end
    end
  end
  return waitKey, false
end
local function moveParentToWait(parentPrefix, parentId, emitEvent)
  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. "meta", parentPrefix .. "active",
    parentPrefix .. "wait", parentPrefix .. "paused")
  addJobInTargetList(parentTarget, parentPrefix .. "marker", "RPUSH", isPausedOrMaxed, parentId)
  if emitEvent then
    local parentEventStream = parentPrefix .. "events"
    rcall("XADD", parentEventStream, "*", "event", "waiting", "jobId", parentId, "prev", "waiting-children")
  end
end
local function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)
  if parentKey then
    local parentDependenciesKey = parentKey .. ":dependencies"
    local result = rcall("SREM", parentDependenciesKey, jobKey)
    if result > 0 then
      local pendingDependencies = rcall("SCARD", parentDependenciesKey)
      if pendingDependencies == 0 then
        local parentId = getJobIdFromKey(parentKey)
        local parentPrefix = getJobKeyPrefix(parentKey, parentId)
        local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)
        if numRemovedElements == 1 then
          if hard then -- remove parent in same queue
            if parentPrefix == baseKey then
              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)
              removeJobKeys(parentKey)
              if debounceId then
                rcall("DEL", parentPrefix .. "de:" .. debounceId)
              end
            else
              moveParentToWait(parentPrefix, parentId)
            end
          else
            moveParentToWait(parentPrefix, parentId, true)
          end
        end
      end
      return true
    end
  else
    local parentAttributes = rcall("HMGET", jobKey, "parentKey", "deid")
    local missedParentKey = parentAttributes[1]
    if( (type(missedParentKey) == "string") and missedParentKey ~= ""
      and (rcall("EXISTS", missedParentKey) == 1)) then
      local parentDependenciesKey = missedParentKey .. ":dependencies"
      local result = rcall("SREM", parentDependenciesKey, jobKey)
      if result > 0 then
        local pendingDependencies = rcall("SCARD", parentDependenciesKey)
        if pendingDependencies == 0 then
          local parentId = getJobIdFromKey(missedParentKey)
          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)
          local numRemovedElements = rcall("ZREM", parentPrefix .. "waiting-children", parentId)
          if numRemovedElements == 1 then
            if hard then
              if parentPrefix == baseKey then
                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)
                removeJobKeys(missedParentKey)
                if parentAttributes[2] then
                  rcall("DEL", parentPrefix .. "de:" .. parentAttributes[2])
                end
              else
                moveParentToWait(parentPrefix, parentId)
              end
            else
              moveParentToWait(parentPrefix, parentId, true)
            end
          end
        end
        return true
      end
    end
  end
  return false
end
local function removeJob(jobId, hard, baseKey, shouldRemoveDeduplicationKey)
  local jobKey = baseKey .. jobId
  removeParentDependencyKey(jobKey, hard, nil, baseKey)
  if shouldRemoveDeduplicationKey then
    removeDeduplicationKey(baseKey, jobKey)
  end
  removeJobKeys(jobKey)
end
local function deleteGroup(groupsSetKey, groupKey, groupId, prefixKey, limit, score)
  local jobIds = rcall("LRANGE", groupKey, 0, limit - 1)
  rcall("LTRIM", groupKey, limit, -1)
  if (#jobIds > 0) then
    for i, jobId in ipairs(jobIds) do
      removeJob(jobId, true, prefixKey)
    end 
    local jobsLeft = rcall("LLEN", groupKey)
    if jobsLeft ~= 0 then
      rcall("ZADD", groupsSetKey, score, groupId)
    end
    return #jobIds, jobsLeft
  end
  return 0, 0
end
local function deleteGroupInSet(groupsSetKey, prefixKey, limit)
  local currentGroup = rcall("ZPOPMIN", groupsSetKey)
  local currentLimit = limit
  if currentGroup[1] ~= nil then
    local groupKey = prefixKey .. 'groups:' .. currentGroup[1]
    local removedJobs, jobsLeft = deleteGroup(groupsSetKey, groupKey,
      currentGroup[1], prefixKey, limit, currentGroup[2])
    currentLimit = currentLimit - removedJobs
  end
  return currentGroup[1], currentLimit
end
local function deleteGroups(groupsKey, prefixKey, limit)
  local groupId
  repeat
    groupId, limit =  deleteGroupInSet(groupsKey, prefixKey, limit)
  until groupId == nil or limit <= 0
  local groupsRateLimitKey = groupsKey .. ':limit'
  if groupId == nil and limit > 0 then
    repeat
      groupId, limit =  deleteGroupInSet(groupsRateLimitKey, prefixKey, limit)
    until groupId == nil or limit <= 0
  end
  local groupsMaxConcurrencyKey = groupsKey .. ':max'
  if groupId == nil and limit > 0 then
    repeat
      groupId, limit =  deleteGroupInSet(groupsMaxConcurrencyKey, prefixKey, limit)
    until groupId == nil or limit <= 0
  end
  local groupsPausedKey = groupsKey .. ':paused'
  if groupId == nil and limit > 0 then
    repeat
      groupId, limit =  deleteGroupInSet(groupsPausedKey, prefixKey, limit)
    until groupId == nil or limit <= 0
  end
  return groupId == nil
end
return deleteGroups(KEYS[2], KEYS[1], tonumber(ARGV[1]))
`;
export const deleteGroups = {
    name: 'deleteGroups',
    content,
    keys: 2,
};
//# sourceMappingURL=deleteGroups-2.js.map