/// <reference types="node" />
import { Worker, IoredisListener } from 'bullmq';
import { JobProJsonRaw, WorkerProOptions } from '../interfaces';
import { JobPro } from './job-pro';
import { ScriptsPro } from '../classes/scripts-pro';
export type ProcessorPro<T = any, R = any, N extends string = string> = (job: JobPro<T, R, N>, token?: string) => Promise<R>;
export interface WorkerProListener<DataType = any, ResultType = any, NameType extends string = string> extends IoredisListener {
    /**
     * Listen to 'active' event.
     *
     * This event is triggered when a job enters the 'active' state.
     */
    active: (job: JobPro<DataType, ResultType, NameType>, prev: string) => void;
    /**
     * Listen to 'closing' event.
     *
     * This event is triggered when the worker is closed.
     */
    closed: () => void;
    /**
     * Listen to 'closing' event.
     *
     * This event is triggered when the worker is closing.
     */
    closing: (msg: string) => void;
    /**
     * Listen to 'completed' event.
     *
     * This event is triggered when a job has successfully completed.
     */
    completed: (job: JobPro<DataType, ResultType, NameType>, result: ResultType, prev: string) => void;
    /**
     * Listen to 'drained' event.
     *
     * This event is triggered when the queue has drained the waiting list.
     * Note that there could still be delayed jobs waiting their timers to expire
     * and this event will still be triggered as long as the waiting list has emptied.
     */
    drained: () => void;
    /**
     * Listen to 'error' event.
     *
     * This event is triggered when an error is throw.
     */
    error: (failedReason: Error) => void;
    /**
     * Listen to 'failed' event.
     *
     * This event is triggered when a job has thrown an exception.
     * Note: job parameter could be received as undefined when an stalled job
     * reaches the stalled limit and it is deleted by the removeOnFail option.
     */
    failed: (job: JobPro<DataType, ResultType, NameType> | undefined, error: Error, prev: string) => void;
    /**
     * Listen to 'paused' event.
     *
     * This event is triggered when the queue is paused.
     */
    paused: () => void;
    /**
     * Listen to 'progress' event.
     *
     * This event is triggered when a job updates it progress, i.e. the
     * Job##updateProgress() method is called. This is useful to notify
     * progress or any other data from within a processor to the rest of the
     * world.
     */
    progress: (job: JobPro<DataType, ResultType, NameType>, progress: number | object) => void;
    /**
     * Listen to 'ready' event.
     *
     * This event is triggered when blockingConnection is ready.
     */
    ready: () => void;
    /**
     * Listen to 'resumed' event.
     *
     * This event is triggered when the queue is resumed.
     */
    resumed: () => void;
    /**
     * Listen to 'stalled' event.
     *
     * This event is triggered when a job has stalled and
     * has been moved back to the wait list.
     */
    stalled: (jobId: string, prev: string) => void;
}
/**
 * @see {@link bullmq!Worker | Worker}
 */
export declare class WorkerPro<DataType = any, ResultType = any, NameType extends string = string> extends Worker<DataType, ResultType, NameType> {
    opts: WorkerProOptions;
    protected scripts: ScriptsPro;
    static RateLimitError: typeof Worker.RateLimitError;
    constructor(name: string, processor?: string | URL | null | ProcessorPro<DataType, ResultType, NameType>, opts?: WorkerProOptions);
    emit<U extends keyof WorkerProListener<DataType, ResultType, NameType>>(event: U, ...args: Parameters<WorkerProListener<DataType, ResultType, NameType>[U]>): boolean;
    off<U extends keyof WorkerProListener<DataType, ResultType, NameType>>(eventName: U, listener: WorkerProListener<DataType, ResultType, NameType>[U]): this;
    on<U extends keyof WorkerProListener<DataType, ResultType, NameType>>(event: U, listener: WorkerProListener<DataType, ResultType, NameType>[U]): this;
    once<U extends keyof WorkerProListener<DataType, ResultType, NameType>>(event: U, listener: WorkerProListener<DataType, ResultType, NameType>[U]): this;
    protected setScripts(): void;
    protected get Job(): typeof JobPro;
    protected callProcessJob(job: JobPro<DataType, ResultType, NameType>, token: string): Promise<ResultType>;
    /**
     * Store returnValue.
     *
     * @param jobId - Job identifier.
     * @param token - Token lock.
     * @param returnValue - The jobs success message.
     */
    private storeResult;
    protected nextJobFromJobData(jobData?: JobProJsonRaw, jobId?: string, token?: string): Promise<JobPro<DataType, ResultType, NameType>>;
    /**
     * Overrides the rate limit so that it becomes active for the given group.
     *
     * @param job - Job currently being processed, and whose group we want to rate limit.
     * @param expireTimeMs - Expire time in ms of this rate limit.
     */
    rateLimitGroup(job: JobPro, expireTimeMs: number): Promise<void>;
    protected extendLocks(jobs: JobPro[]): Promise<void>;
}
