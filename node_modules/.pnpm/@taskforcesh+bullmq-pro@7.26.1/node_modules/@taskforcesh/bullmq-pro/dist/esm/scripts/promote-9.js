const content = `--[[
  Promotes a job that is currently "delayed" to the "waiting" state
    Input:
      KEYS[1] 'delayed'
      KEYS[2] 'wait'
      KEYS[3] 'paused'
      KEYS[4] 'meta'
      KEYS[5] 'prioritized'
      KEYS[6] 'active'
      KEYS[7] 'pc' priority counter
      KEYS[8] 'event stream'
      KEYS[9] 'marker'
      ARGV[1]  queue.toKey('')
      ARGV[2]  jobId
    Events:
      'waiting'
]]
local rcall = redis.call;
local jobId = ARGV[2]
-- Includes
--[[
  Function to add job in target list and add marker if needed.
]]
-- Includes
--[[
  Add marker if needed when a job is available.
]]
local function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)
  if not isPausedOrMaxed then
    rcall("ZADD", markerKey, 0, "0")
  end  
end
local function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)
  rcall(pushCmd, targetKey, jobId)
  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)
end
--[[
  Function to check for the meta.paused key to decide if we are paused or not
  (since an empty list and !EXISTS are not really the same).
]]
local function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)
  local queueAttributes = rcall("HMGET", queueMetaKey, "paused", "concurrency")
  if queueAttributes[1] then
    return pausedKey, true
  else
    if queueAttributes[2] then
      local activeCount = rcall("LLEN", activeKey)
      if activeCount >= tonumber(queueAttributes[2]) then
        return waitKey, true
      else
        return waitKey, false
      end
    end
  end
  return waitKey, false
end
--[[
  Function to add job considering priority.
]]
-- Includes
local function addJobWithPriority(markerKey, prioritizedKey, priority, jobId,
    priorityCounterKey, isPausedOrMaxed, groupId)
  local prioCounter
  if groupId then
    prioCounter = rcall("HINCRBY", priorityCounterKey, groupId, 1)
  else
    prioCounter = rcall("INCR", priorityCounterKey)
  end
  local score = priority * 0x100000000 + prioCounter % 0x100000000
  rcall("ZADD", prioritizedKey, score, jobId)
  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)
end
-- Includes
--[[
  Function to push back job considering priority in front of same prioritized jobs.
]]
local function pushBackJobWithPriority(prioritizedKey, priority, jobId)
  -- in order to put it at front of same prioritized jobs
  -- we consider prioritized counter as 0
  local score = priority * 0x100000000
  rcall("ZADD", prioritizedKey, score, jobId)
end
local function moveJobToTargetGroup(pushCmd, prefixKey, groupKey, groupId, jobId, markerKey, priority,
    isPaused, pushBack)
    if priority == 0 then
        addJobInTargetList(groupKey, markerKey, pushCmd, isPaused, jobId)
    elseif pushBack then
        pushBackJobWithPriority(groupKey .. ":p", priority, jobId)
    else
        addJobWithPriority(markerKey, groupKey .. ":p", priority, jobId,
            prefixKey .. "groups:pc", isPaused, groupId)
    end
end
local function addToGroup(lifo, prefixKey, groupId, jobId, markerKey, priority, isPaused, pushBack)
    local groupKey = prefixKey .. 'groups:' .. groupId
    local pushCmd = lifo and 'RPUSH' or 'LPUSH';
    --if group is paused we do not need to check for rate limit
    if rcall("ZSCORE", prefixKey .. 'groups:paused', groupId) ~= false then
        -- set isPaused as true in order to avoid adding marker
        moveJobToTargetGroup(pushCmd, prefixKey, groupKey, groupId, jobId, markerKey, priority, true, pushBack)
    else
        -- Has this group reached maximum concurrency?
        local hasReachedMaxConcurrency = rcall("ZSCORE", prefixKey .. 'groups:max', groupId) ~= false
        -- Is group rate limited?
        local groupRateLimitKey = groupKey .. ':limit'
        local jobCounter = tonumber(rcall("GET", groupRateLimitKey))
        local isRateLimited = jobCounter and jobCounter >= 999999
        if hasReachedMaxConcurrency or isRateLimited then
            -- set isPaused as true in order to avoid adding marker
            moveJobToTargetGroup(pushCmd, prefixKey, groupKey, groupId, jobId, markerKey, priority, true, pushBack)
        else
            moveJobToTargetGroup(pushCmd, prefixKey, groupKey, groupId, jobId, markerKey, priority, isPaused, pushBack)
            local groupsKey = prefixKey .. 'groups'
            local highscore = rcall("ZREVRANGE", groupsKey, 0, 0,
                "withscores")[2] or 0
            rcall("ZADD", groupsKey, highscore + 1, groupId)
        end
    end
end
if rcall("ZREM", KEYS[1], jobId) == 1 then
  local jobKey = ARGV[1] .. jobId
  local jobAttributes = rcall("HMGET", jobKey, "priority", "gid")
  local priority = tonumber(jobAttributes[1]) or 0
  local target, isPausedOrMaxed = getTargetQueueList(KEYS[4], KEYS[6], KEYS[2], KEYS[3])
  -- Remove delayed "marker" from the wait list if there is any.
  -- Since we are adding a job we do not need the marker anymore.
  local marker = rcall("LINDEX", target, 0)
  if marker and string.sub(marker, 1, 2) == "0:" then
    rcall("LPOP", target)
  end
  local markerKey = KEYS[9]
  if jobAttributes[2] then
    addToGroup(false, ARGV[1], jobAttributes[2], jobId, markerKey, priority, isPausedOrMaxed, false)
  elseif priority == 0 then
    -- LIFO or FIFO
    addJobInTargetList(target, markerKey, "LPUSH", isPausedOrMaxed, jobId)
  else
    addJobWithPriority(markerKey, KEYS[5], priority, jobId, KEYS[7], isPausedOrMaxed, nil)
  end
  -- Emit waiting event (wait..ing@token)
  rcall("XADD", KEYS[8], "*", "event", "waiting", "jobId", jobId, "prev", "delayed");
  rcall("HSET", jobKey, "delay", 0)
  return 0
else
  return -3
end`;
export const promote = {
    name: 'promote',
    content,
    keys: 9,
};
//# sourceMappingURL=promote-9.js.map