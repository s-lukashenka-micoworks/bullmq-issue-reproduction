--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the lock
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] prioritized key
      KEYS[4] stream events key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      -- Promote delayed jobs
      KEYS[8] paused key
      KEYS[9] meta key

      KEYS[10] pc priority counter

      -- Marker
      KEYS[11] marker key

      -- Arguments
      ARGV[1] key prefix
      ARGV[2] timestamp
      ARGV[3] options
]]
local rcall = redis.call
local waitKey = KEYS[1]
local activeKey = KEYS[2]
local rateLimiterKey = KEYS[6]
local delayedKey = KEYS[7]
local prefixKey = ARGV[1]
local timestamp = tonumber(ARGV[2])
local opts = cmsgpack.unpack(ARGV[3])

-- Includes
--- @include "<base>/includes/getRateLimitTTL"
--- @include "<base>/includes/getTargetQueueList"
--- @include "includes/promoteDelayedJobs"
--- @include "includes/promoteRateLimitedGroups"
--- @include "includes/fetchNextJob"
--- @include "includes/moveNextBatch"

local target, isPausedOrMaxed = getTargetQueueList(KEYS[9], KEYS[2], KEYS[1], KEYS[8])

-- Check if there are delayed jobs that we can move to wait.
local markerKey = KEYS[11]
promoteDelayedJobs(delayedKey, markerKey, target, KEYS[3], KEYS[4],
                   prefixKey, timestamp, KEYS[10], isPausedOrMaxed)

local maxJobs = tonumber(opts['limiter'] and opts['limiter']['max'])
local expireTime = getRateLimitTTL(maxJobs, rateLimiterKey)

-- Check if we are rate limited first.
if expireTime > 0 then return {0, 0, expireTime, 0} end

-- paused queue
if isPausedOrMaxed then return {0, 0, 0, 0} end

if opts.batch then
    local rateLimitedNextTtl = promoteRateLimitedGroups(prefixKey, markerKey,
                                                        timestamp, isPausedOrMaxed)

    local batchSize = (opts.batch and opts.batch.size) or 1
    return moveNextBatch(waitKey, activeKey, delayedKey, rateLimiterKey,
                         KEYS[4], prefixKey, opts, batchSize, timestamp, markerKey,
                         rateLimiterKey, maxJobs, KEYS)
else
    return fetchNextJob(waitKey, activeKey, delayedKey, rateLimiterKey,
                        KEYS[4], prefixKey, opts, timestamp, markerKey, false,
                        maxJobs, KEYS, nil, false)
end
