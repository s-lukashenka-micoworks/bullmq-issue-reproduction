/// <reference types="node" />
import { FinishedPropValAttribute, FinishedStatus, JobState, KeepJobs, MinimalJob, MinimalQueue, MoveToDelayedOpts, MoveToWaitingChildrenOpts, Scripts, RedisClient } from 'bullmq';
import { GroupStatus } from '../enums/group-status';
/**
 * Implementation of the Scripts interface.
 * In the future we may refactor the Scripts interface in BullMQ so that extensions
 * can just extend the Scripts implementation and replace by its own commands.
 */
export declare class ScriptsPro extends Scripts {
    protected queue: MinimalQueue;
    protected version: string;
    constructor(queue: MinimalQueue);
    getGroupRateLimitTtlArgs(groupId: string | number, maxJobs?: number): (string | number)[];
    getGroupRateLimitTtl(groupId: string | number, maxJobs?: number): Promise<number>;
    pauseArgs(pause: boolean): (string | number)[];
    moveToDelayedArgs(jobId: string, timestamp: number, token: string, delay: number, opts?: MoveToDelayedOpts): (string | number | Buffer)[];
    protected moveStalledJobsToWaitArgs(): (string | number)[];
    retryJobArgs(jobId: string, lifo: boolean, token: string, fieldsToUpdate?: Record<string, any>): (string | number | Buffer)[];
    moveToActive(client: RedisClient, token: string, name?: string): Promise<any[]>;
    moveToBatchFinished(client: RedisClient, jobs: MinimalJob[], propVal: FinishedPropValAttribute, target: FinishedStatus, token: string, timestamp: number, fetchNext?: boolean): any;
    protected moveToFinishedArgs(job: MinimalJob, val: any, propVal: FinishedPropValAttribute, shouldRemove: undefined | boolean | number | KeepJobs, target: FinishedStatus, token: string, timestamp: number, fetchNext?: boolean, fieldsToUpdate?: Record<string, any>): (string | number | boolean | Buffer)[];
    moveToWaitingChildrenArgs(jobId: string, token: string, opts?: MoveToWaitingChildrenOpts): (string | number)[];
    private getCountsPerPriorityForGroupArgs;
    getCountsPerPriorityForGroup(groupId: string, priorities: number[]): Promise<number[]>;
    private deleteGroupArgs;
    deleteGroup(groupId: string | number): Promise<number>;
    private deleteGroupsArgs;
    deleteGroups(): Promise<number>;
    private getGroupJobsCountArgs;
    getGroupJobsCount(groupId: string | number): Promise<number>;
    private getGroupJobsArgs;
    getGroupJobs(groupId: string | number, start?: number, end?: number): Promise<string[]>;
    private storeResultArgs;
    storeResult<ResultType = any>(jobId: string, token: string, returnValue: ResultType): Promise<void>;
    /**
     * Moves a job back from Active to Wait.
     * This script is used when a job has been manually rate limited and needs
     * to be moved back to wait from active status.
     *
     * @param client - Redis client
     * @param jobId - Job id
     * @returns
     */
    moveJobFromActiveToWait(jobId: string, token: string): Promise<any>;
    getGroups(start?: number, end?: number): Promise<[
        string[] | undefined,
        string[] | undefined,
        string[] | undefined,
        string[] | undefined,
        number
    ]>;
    getGroupsCount(client: RedisClient, start?: number, end?: number, groupState?: string): Promise<[number, string, number]>;
    private groupStatus2Key;
    getGroupsByStatus(status: GroupStatus, start?: number, end?: number): Promise<[string[], number[]]>;
    getState(jobId: string): Promise<JobState | 'unknown'>;
    pauseGroup(groupId: string | number, pause: boolean): Promise<boolean>;
    /**
     * Rate limit a group.
     *
     * @param jobId - the job id that cased this group to be rate limited
     * @param groupId - the group id
     * @param expirationTimeMs - the expiration time in milliseconds
     * @returns
     */
    rateLimitGroup(groupId: string, expirationTimeMs: number): Promise<void>;
    remove(jobId: string, removeChildren: boolean): Promise<number>;
    /**
     * Repairs a maxed group.
     *
     * It seems that in some unknown situations a group can become maxed although there
     * are no active jobs in the group. This function will try to repair this situation.
     *
     * @param groupId -
     * @returns
     */
    repairMaxedGroup(groupId: string, concurrency?: number): Promise<any>;
    /**
     * Repairs stalled key when you are migrating from v4 or below to v6 or above.
     * This key used a zset and now it uses a set, this is why this method is needed.
     * An error like: 'WRONGTYPE Operation against a key holding the wrong kind of
     * value' in moveStalledJobsToWait script is a good indicator of this change.
     * Note: Migration from v5 to v6 won't need to call this method
     */
    repairStalledKey(): Promise<any>;
    finishedErrors({ code, jobId, parentKey, command, state, }: {
        code: number;
        jobId?: string;
        parentKey?: string;
        command: string;
        state?: string;
    }): Error;
}
