import { getParentKey, Scripts, raw2NextJobData, isRedisVersionLowerThan, array2obj, tryCatch, objectToFlatArray, } from 'bullmq';
import { ErrorCodePro } from '../enums/error-code-pro.enum';
import { GroupStatus } from '../enums/group-status';
import { ErrorCode } from '../enums';
import { version as packageVersion } from '../version';
import { Packr } from 'msgpackr';
import { performance } from 'perf_hooks';
import { GroupMaxSizeExceededError } from './errors';
const baseTimestamp = Date.now() - performance.now();
function getTimestamp() {
    return baseTimestamp + performance.now();
}
const packer = new Packr({
    useRecords: false,
    encodeUndefinedAsNil: true,
});
const pack = packer.pack;
const MAX_GROUP_DELETE_ITER = 100;
/**
 * Implementation of the Scripts interface.
 * In the future we may refactor the Scripts interface in BullMQ so that extensions
 * can just extend the Scripts implementation and replace by its own commands.
 */
export class ScriptsPro extends Scripts {
    constructor(queue) {
        super(queue);
        this.queue = queue;
        this.version = packageVersion;
    }
    getGroupRateLimitTtlArgs(groupId, maxJobs) {
        const keys = [
            this.queue.toKey(`groups:${groupId}:limit`),
        ];
        return keys.concat([maxJobs !== null && maxJobs !== void 0 ? maxJobs : '0']);
    }
    async getGroupRateLimitTtl(groupId, maxJobs) {
        const client = await this.queue.client;
        const args = this.getGroupRateLimitTtlArgs(groupId, maxJobs);
        return this.execCommand(client, 'getRateLimitTtl', args);
    }
    pauseArgs(pause) {
        let src = 'wait', dst = 'paused';
        if (!pause) {
            src = 'paused';
            dst = 'wait';
        }
        const keys = [src, dst, 'meta', 'prioritized'].map((name) => this.queue.toKey(name));
        keys.push(this.queue.keys.events, this.queue.keys.delayed, this.queue.keys.marker, this.queue.toKey('groups'));
        const args = [pause ? 'paused' : 'resumed'];
        return keys.concat(args);
    }
    moveToDelayedArgs(jobId, timestamp, token, delay, opts = {}) {
        var _a;
        const workerOpts = this.queue.opts;
        const queueKeys = this.queue.keys;
        const keys = [
            queueKeys.marker,
            queueKeys.active,
            queueKeys.prioritized,
            queueKeys.delayed,
            this.queue.toKey(jobId),
            queueKeys.events,
            queueKeys.meta,
            queueKeys.stalled,
        ];
        return keys.concat([
            this.queue.keys[''],
            timestamp,
            jobId,
            token,
            delay,
            (_a = workerOpts.group) === null || _a === void 0 ? void 0 : _a.concurrency,
            opts.skipAttempt ? '1' : '0',
            opts.fieldsToUpdate
                ? pack(objectToFlatArray(opts.fieldsToUpdate))
                : void 0,
        ]);
    }
    moveStalledJobsToWaitArgs() {
        var _a;
        const opts = this.queue.opts;
        const keys = [
            this.queue.keys.stalled,
            this.queue.keys.wait,
            this.queue.keys.active,
            this.queue.keys.failed,
            this.queue.keys['stalled-check'],
            this.queue.keys.meta,
            this.queue.keys.paused,
            this.queue.keys.marker,
            this.queue.keys.events,
        ];
        const args = [
            opts.maxStalledCount,
            this.queue.toKey(''),
            Date.now(),
            opts.stalledInterval,
            (_a = opts.group) === null || _a === void 0 ? void 0 : _a.concurrency,
        ];
        return keys.concat(args);
    }
    retryJobArgs(jobId, lifo, token, fieldsToUpdate) {
        var _a;
        const opts = this.queue.opts;
        const keys = [
            this.queue.keys.active,
            this.queue.keys.wait,
            this.queue.keys.paused,
            this.queue.toKey(jobId),
            this.queue.keys.meta,
            this.queue.keys.events,
            this.queue.keys.delayed,
            this.queue.keys.prioritized,
            this.queue.keys.pc,
            this.queue.keys.marker,
            this.queue.keys.limiter,
        ];
        const pushCmd = (lifo ? 'R' : 'L') + 'PUSH';
        return keys.concat([
            this.queue.toKey(''),
            Date.now(),
            pushCmd,
            jobId,
            token,
            (_a = opts.group) === null || _a === void 0 ? void 0 : _a.concurrency,
            fieldsToUpdate ? pack(objectToFlatArray(fieldsToUpdate)) : void 0,
        ]);
    }
    async moveToActive(client, token, name) {
        var _a;
        const opts = this.queue.opts;
        const queueKeys = this.queue.keys;
        const keys = [
            queueKeys.wait,
            queueKeys.active,
            queueKeys.prioritized,
            queueKeys.events,
            queueKeys.stalled,
            queueKeys.limiter,
            queueKeys.delayed,
            queueKeys.paused,
            queueKeys.meta,
            queueKeys.pc,
            queueKeys.marker,
        ];
        const args = [
            queueKeys[''],
            Date.now(),
            pack({
                token,
                lockDuration: opts.lockDuration,
                limiter: opts.limiter,
                name,
                group: opts.group,
                batch: opts.batch,
            }),
        ];
        const result = await this.execCommand(client, 'moveToActive', keys.concat(args));
        if (result && ((_a = opts.batch) === null || _a === void 0 ? void 0 : _a.size)) {
            const rawJobs = result[0];
            const jobs = [];
            for (let i = 0; i < rawJobs.length; i++) {
                jobs.push(array2obj(rawJobs[i]));
            }
            return [
                jobs.length ? jobs : undefined,
                result[1],
                result[2],
                result[3],
                result[4],
            ];
        }
        return raw2NextJobData(result);
    }
    moveToBatchFinished(client, jobs, propVal, target, token, timestamp, fetchNext = true) {
        var _a, _b, _c, _d;
        const queueKeys = this.queue.keys;
        const opts = this.queue.opts;
        const workerKeepJobs = target === 'completed' ? opts.removeOnComplete : opts.removeOnFail;
        const metricsKey = this.queue.toKey(`metrics:${target}`);
        const keys = [
            queueKeys.wait,
            queueKeys.active,
            queueKeys.prioritized,
            queueKeys.events,
            queueKeys.stalled,
            queueKeys.limiter,
            queueKeys.delayed,
            queueKeys.paused,
            queueKeys.meta,
            queueKeys.pc,
            queueKeys[target],
            metricsKey,
            queueKeys.marker,
        ];
        const args = [
            pack({
                ts: timestamp,
                f: propVal,
                t: target,
                p: queueKeys[''],
                fn: fetchNext && ((_a = opts === null || opts === void 0 ? void 0 : opts.batch) === null || _a === void 0 ? void 0 : _a.size) > 0 ? (_b = opts === null || opts === void 0 ? void 0 : opts.batch) === null || _b === void 0 ? void 0 : _b.size : 0,
                jobs: jobs.map(job => {
                    var _a, _b;
                    return ({
                        id: job.id,
                        v: tryCatch(JSON.stringify, JSON, [job[propVal]]),
                        a: job.opts.attempts,
                        fpof: !!((_a = job.opts) === null || _a === void 0 ? void 0 : _a.failParentOnFailure),
                        rdof: !!((_b = job.opts) === null || _b === void 0 ? void 0 : _b.removeDependencyOnFailure),
                        kj: this.getKeepJobs(target === 'completed'
                            ? job.opts.removeOnComplete
                            : job.opts.removeOnFail, workerKeepJobs),
                    });
                }),
            }),
            pack({
                token,
                limiter: opts.limiter,
                lockDuration: opts.lockDuration,
                group: opts.group,
                maxMetricsSize: ((_c = opts.metrics) === null || _c === void 0 ? void 0 : _c.maxDataPoints)
                    ? (_d = opts.metrics) === null || _d === void 0 ? void 0 : _d.maxDataPoints
                    : '',
            }),
        ];
        return this.execCommand(client, 'moveBatchToFinished', keys.concat(args));
    }
    // TODO: This method is basically identical to the one in BullMQ,
    // except for the group options. We should refactor this in the future.
    moveToFinishedArgs(job, val, propVal, shouldRemove, target, token, timestamp, fetchNext = true, fieldsToUpdate) {
        var _a, _b, _c, _d, _e, _f;
        const queueKeys = this.queue.keys;
        const opts = this.queue.opts;
        const workerKeepJobs = target === 'completed' ? opts.removeOnComplete : opts.removeOnFail;
        const metricsKey = this.queue.toKey(`metrics:${target}`);
        const keys = this.moveToFinishedKeys;
        keys[10] = queueKeys[target];
        keys[11] = this.queue.toKey((_a = job.id) !== null && _a !== void 0 ? _a : '');
        keys[12] = metricsKey;
        keys[13] = this.queue.keys.marker;
        const keepJobs = this.getKeepJobs(shouldRemove, workerKeepJobs);
        const args = [
            job.id,
            timestamp,
            propVal,
            typeof val === 'undefined' ? 'null' : val,
            target,
            !fetchNext || this.queue.closing ? 0 : 1,
            queueKeys[''],
            pack({
                token,
                keepJobs,
                limiter: opts.limiter,
                lockDuration: opts.lockDuration,
                group: opts.group,
                attempts: job.opts.attempts,
                maxMetricsSize: ((_b = opts.metrics) === null || _b === void 0 ? void 0 : _b.maxDataPoints)
                    ? (_c = opts.metrics) === null || _c === void 0 ? void 0 : _c.maxDataPoints
                    : '',
                fpof: !!((_d = job.opts) === null || _d === void 0 ? void 0 : _d.failParentOnFailure),
                idof: !!((_e = job.opts) === null || _e === void 0 ? void 0 : _e.ignoreDependencyOnFailure),
                rdof: !!((_f = job.opts) === null || _f === void 0 ? void 0 : _f.removeDependencyOnFailure),
            }),
            fieldsToUpdate ? pack(objectToFlatArray(fieldsToUpdate)) : void 0,
        ];
        return keys.concat(args);
    }
    moveToWaitingChildrenArgs(jobId, token, opts) {
        var _a;
        const workerOpts = this.queue.opts;
        const timestamp = Date.now();
        const childKey = getParentKey(opts.child);
        const keys = [
            '',
            `${jobId}:lock`,
            'active',
            'waiting-children',
            jobId,
            'stalled',
            'marker',
            'meta',
        ].map(name => {
            return this.queue.toKey(name);
        });
        return keys.concat([
            token,
            childKey !== null && childKey !== void 0 ? childKey : '',
            JSON.stringify(timestamp),
            jobId,
            (_a = workerOpts.group) === null || _a === void 0 ? void 0 : _a.concurrency,
        ]);
    }
    getCountsPerPriorityForGroupArgs(groupId, priorities) {
        const keys = [
            `groups:${groupId}`,
            `groups:${groupId}:p`,
        ].map((key) => {
            return this.queue.toKey(key);
        });
        const args = priorities;
        return keys.concat(args);
    }
    async getCountsPerPriorityForGroup(groupId, priorities) {
        const client = await this.queue.client;
        const args = this.getCountsPerPriorityForGroupArgs(groupId, priorities);
        return this.execCommand(client, 'getCountsPerPriorityForGroup', args);
    }
    deleteGroupArgs(groupId) {
        const keys = ['', `groups:${groupId}`, 'groups'].map((key) => {
            return this.queue.toKey(key);
        });
        const args = [groupId, MAX_GROUP_DELETE_ITER];
        return keys.concat(args);
    }
    async deleteGroup(groupId) {
        const client = await this.queue.client;
        const args = this.deleteGroupArgs(groupId);
        return this.execCommand(client, 'deleteGroup', args);
    }
    deleteGroupsArgs() {
        const keys = ['', 'groups'].map((key) => {
            return this.queue.toKey(key);
        });
        const args = [MAX_GROUP_DELETE_ITER];
        return keys.concat(args);
    }
    async deleteGroups() {
        const client = await this.queue.client;
        const args = this.deleteGroupsArgs();
        return this.execCommand(client, 'deleteGroups', args);
    }
    getGroupJobsCountArgs(groupId) {
        const keys = [this.queue.toKey('')];
        const args = [groupId];
        return keys.concat(args);
    }
    async getGroupJobsCount(groupId) {
        const client = await this.queue.client;
        const args = this.getGroupJobsCountArgs(groupId);
        return this.execCommand(client, 'getGroupCount', args);
    }
    getGroupJobsArgs(groupId, start = 0, end = -1) {
        const keys = [
            this.queue.toKey(''),
            this.queue.toKey(`groups:${groupId}`),
        ];
        const args = [groupId, start, end];
        return keys.concat(args);
    }
    async getGroupJobs(groupId, start = 0, end = -1) {
        const client = await this.queue.client;
        const args = this.getGroupJobsArgs(groupId, start, end);
        return this.execCommand(client, 'getGroup', args);
    }
    storeResultArgs(jobId, token, returnValue) {
        const keys = [
            this.queue.toKey(jobId),
            this.queue.toKey(`${jobId}:lock`),
        ];
        const args = [token, JSON.stringify(returnValue)];
        return keys.concat(args);
    }
    async storeResult(jobId, token, returnValue) {
        const client = await this.queue.client;
        const args = this.storeResultArgs(jobId, token, returnValue);
        const result = await this.execCommand(client, 'storeResult', args);
        if (result < 0) {
            throw this.finishedErrors({
                code: result,
                jobId,
                command: 'storeResult',
            });
        }
    }
    /**
     * Moves a job back from Active to Wait.
     * This script is used when a job has been manually rate limited and needs
     * to be moved back to wait from active status.
     *
     * @param client - Redis client
     * @param jobId - Job id
     * @returns
     */
    async moveJobFromActiveToWait(jobId, token) {
        var _a;
        const client = await this.queue.client;
        const lockKey = `${this.queue.toKey(jobId)}:lock`;
        const opts = this.queue.opts;
        const keys = [
            this.queue.keys.active,
            this.queue.keys.wait,
            this.queue.keys.stalled,
            lockKey,
            this.queue.keys.paused,
            this.queue.keys.meta,
            this.queue.keys.limiter,
            this.queue.keys.prioritized,
            this.queue.keys.marker,
            this.queue.keys.events,
        ];
        const args = [
            jobId,
            token,
            this.queue.toKey(''),
            (_a = opts === null || opts === void 0 ? void 0 : opts.group) === null || _a === void 0 ? void 0 : _a.concurrency,
            this.queue.toKey(jobId),
        ];
        return this.execCommand(client, 'moveJobFromActiveToWait', keys.concat(args));
    }
    async getGroups(start = 0, end = -1) {
        const client = await this.queue.client;
        const result = await this.execCommand(client, 'getGroups', [
            this.queue.toKey('groups'),
            this.queue.toKey('groups:limit'),
            this.queue.toKey('groups:max'),
            this.queue.toKey('groups:paused'),
            start,
            end,
        ]);
        return result;
    }
    async getGroupsCount(client, start = 0, end = 99, groupState = 'waiting') {
        return this.execCommand(client, 'getGroupsCount', [
            this.queue.toKey(''),
            this.queue.toKey('groups'),
            this.queue.toKey('groups:limit'),
            this.queue.toKey('groups:max'),
            this.queue.toKey('groups:paused'),
            start,
            end,
            groupState,
        ]);
    }
    groupStatus2Key(status) {
        switch (status) {
            case GroupStatus.Waiting:
                return this.queue.toKey('groups');
            case GroupStatus.Limited:
                return this.queue.toKey('groups:limit');
            case GroupStatus.Maxed:
                return this.queue.toKey('groups:max');
            case GroupStatus.Paused:
                return this.queue.toKey('groups:paused');
            default:
                throw new Error(`Invalid group status: ${status}`);
        }
    }
    async getGroupsByStatus(status, start = 0, end = -1) {
        const client = await this.queue.client;
        const groupsKey = this.groupStatus2Key(status);
        const prefix = this.queue.toKey('groups');
        return this.execCommand(client, 'getGroupsByKey', [
            groupsKey,
            prefix,
            start,
            end,
        ]);
    }
    async getState(jobId) {
        const client = await this.queue.client;
        const keys = [
            'completed',
            'failed',
            'delayed',
            'active',
            'wait',
            'paused',
            'waiting-children',
            'prioritized',
            '',
        ].map((key) => {
            return this.queue.toKey(key);
        });
        if (isRedisVersionLowerThan(this.queue.redisVersion, '6.0.6')) {
            return this.execCommand(client, 'getState', keys.concat([jobId]));
        }
        return this.execCommand(client, 'getStateV2', keys.concat([jobId]));
    }
    async pauseGroup(groupId, pause) {
        const client = await this.queue.client;
        const keys = [
            'wait',
            `groups:${groupId}`,
            'groups',
            'groups:paused',
            `groups:${groupId}:limit`,
            'groups:limit',
            'groups:max',
            'marker',
            'meta',
            'paused',
            'active',
            'events',
        ].map((key) => {
            return this.queue.toKey(key);
        });
        const code = await this.execCommand(client, 'pauseGroup', keys.concat([groupId, pause ? '0' : '1', getTimestamp()]));
        return code === 0;
    }
    /**
     * Rate limit a group.
     *
     * @param jobId - the job id that cased this group to be rate limited
     * @param groupId - the group id
     * @param expirationTimeMs - the expiration time in milliseconds
     * @returns
     */
    async rateLimitGroup(groupId, expirationTimeMs) {
        const client = await this.queue.client;
        const keys = [
            this.queue.toKey(`groups:${groupId}`),
            this.queue.toKey(`groups:${groupId}:limit`),
            this.queue.toKey(`groups`),
            this.queue.toKey(`groups:limit`),
        ];
        return this.execCommand(client, 'rateLimitGroup', keys.concat([expirationTimeMs, Date.now(), groupId]));
    }
    async remove(jobId, removeChildren) {
        const client = await this.queue.client;
        const keys = ['', 'meta', 'marker'].map(name => this.queue.toKey(name));
        const result = await this.execCommand(client, 'removeJob', keys.concat([jobId, removeChildren ? 1 : 0]));
        if (result == ErrorCode.JobBelongsToJobScheduler) {
            throw this.finishedErrors({
                code: ErrorCode.JobBelongsToJobScheduler,
                jobId,
                command: 'remove',
            });
        }
        return result;
    }
    /**
     * Repairs a maxed group.
     *
     * It seems that in some unknown situations a group can become maxed although there
     * are no active jobs in the group. This function will try to repair this situation.
     *
     * @param groupId -
     * @returns
     */
    async repairMaxedGroup(groupId, concurrency) {
        const client = await this.queue.client;
        const keys = [
            this.queue.toKey('groups:active:count'),
            this.queue.toKey('groups:max'),
            this.queue.keys.active,
            this.queue.toKey('groups'),
        ];
        return this.execCommand(client, 'repairMaxedGroup', keys.concat([
            groupId,
            this.queue.toKey(''),
            concurrency ? concurrency : 0,
        ]));
    }
    /**
     * Repairs stalled key when you are migrating from v4 or below to v6 or above.
     * This key used a zset and now it uses a set, this is why this method is needed.
     * An error like: 'WRONGTYPE Operation against a key holding the wrong kind of
     * value' in moveStalledJobsToWait script is a good indicator of this change.
     * Note: Migration from v5 to v6 won't need to call this method
     */
    async repairStalledKey() {
        const client = await this.queue.client;
        const keys = [this.queue.keys.stalled];
        return this.execCommand(client, 'repairStalledKey', keys);
    }
    finishedErrors({ code, jobId, parentKey, command, state, }) {
        switch (code) {
            case ErrorCodePro.GroupMaxSizeExceededError:
                return new GroupMaxSizeExceededError(`Group's max size exceeded for job`);
            default:
                return super.finishedErrors({
                    code,
                    jobId,
                    parentKey,
                    command,
                    state,
                });
        }
    }
}
//# sourceMappingURL=scripts-pro.js.map