--[[
    Fetches the next job to be processed and locks it atomically for the specified worker.

    If there are jobs but they are delayed or rate limit, this function will return the next
    delayed or rate limited timestamp so that the worker can sleep until that time before
    asking for a new job again.
]]

-- Includes
--- @include "<base>/includes/getNextDelayedTimestamp"
--- @include "moveJobFromPrioritizedToActive"
--- @include "moveJobToActiveFromGroup"
--- @include "prepareJobForProcessing"
--- @include "promoteRateLimitedGroups"

-- TODO: parametrize KEYS
local function fetchNextJob(waitKey, activeKey, delayedKey,
                            rateLimiterKey, eventStreamKey, prefixKey, opts,
                            timestamp, markerKey, paused, maxJobs, KEYS,
                            rateLimitedNextTtl, checkDrained)

    -- Check if we move this call outside of the function so that it is only performed once per batch.
    if not rateLimitedNextTtl then
        -- TODO: add default value 0 in rateLimitedNextTtl
        rateLimitedNextTtl = promoteRateLimitedGroups(prefixKey, markerKey, timestamp, paused)
    end

    local jobId = rcall("RPOPLPUSH", waitKey, activeKey)

    -- If jobId is special ID 0:delay, then there is no job to process
    if jobId then
        if string.sub(jobId, 1, 2) == "0:" then
            rcall("LREM", activeKey, 1, jobId)
            jobId = rcall("RPOPLPUSH", waitKey, activeKey)
        end
    end

    if jobId then
        return prepareJobForProcessing(prefixKey, rateLimiterKey, eventStreamKey, jobId, timestamp,
            maxJobs, markerKey, opts, rateLimitedNextTtl)
    else
        jobId = moveJobFromPrioritizedToActive(KEYS[3], activeKey, KEYS[10], nil)

        if jobId then
            return prepareJobForProcessing(prefixKey, rateLimiterKey, eventStreamKey, jobId, timestamp,
                maxJobs, markerKey, opts, rateLimitedNextTtl)
        else
            local groupLimit
            local groupLimitDuration
            local groupMaxConcurrency

            if opts['group'] then
                if opts['group']['limit'] then
                    groupLimit = opts['group']['limit']['max']
                    groupLimitDuration = opts['group']['limit']['duration']
                end
                groupMaxConcurrency = opts['group']['concurrency']
            end
            jobId = moveJobToActiveFromGroup(prefixKey, activeKey, groupMaxConcurrency, groupLimit,
                                            groupLimitDuration, timestamp)
            if jobId then
                return prepareJobForProcessing(prefixKey, rateLimiterKey, eventStreamKey, jobId,
                                                timestamp, maxJobs, markerKey, opts, rateLimitedNextTtl)
            end
        end
    end

    -- Return the timestamp for the next delayed job if any.
    local nextTimestamp = getNextDelayedTimestamp(delayedKey)

    if nextTimestamp ~= nil then
        -- The result is guaranteed to be positive, since the
        -- ZRANGEBYSCORE command would have return a job otherwise.
        return {0, 0, 0, nextTimestamp}
    end

    if checkDrained then
        local waitLen = rcall("LLEN", waitKey)
        if waitLen == 0 then
            local activeLen = rcall("LLEN", activeKey)
    
            if activeLen == 0 then
                local prioritizedLen = rcall("ZCARD", KEYS[3])
    
                if prioritizedLen == 0 then
                    rcall("XADD", eventStreamKey, "*", "event", "drained")
                end
            end
        end
    end

    return {0, 0, 0, rateLimitedNextTtl or 0}
end
