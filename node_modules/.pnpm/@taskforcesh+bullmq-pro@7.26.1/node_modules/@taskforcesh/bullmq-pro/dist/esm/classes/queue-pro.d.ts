import { Queue } from 'bullmq';
import { ScriptsPro } from '../classes/scripts-pro';
import { GroupStatus } from '../enums/group-status';
import { QueueProOptions, JobsProOptions } from '../interfaces';
import { JobPro } from './job-pro';
export type BulkJobProOptions = Omit<JobsProOptions, 'repeat'>;
/**
 * QueuePro extends the functionality of Queue with additional
 * features for handling job groups, rate limiting, concurrency
 * per group, and more.
 *
 * @template DataType - The type of the job data.
 * @template ResultType - The type of the job result.
 * @template NameType - The type of the job name.
 *
 */
export declare class QueuePro<DataType = any, ResultType = any, NameType extends string = string> extends Queue<JobPro<DataType, ResultType, NameType>> {
    opts: QueueProOptions;
    protected scripts: ScriptsPro;
    protected libName: string;
    constructor(name: string, opts?: QueueProOptions);
    protected setScripts(): void;
    get metaValues(): Record<string, string | number>;
    /**
     * Get library version.
     *
     * @returns the content of the meta.library field.
     */
    getVersion(): Promise<string>;
    /**
     * Adds a Job to the queue.
     *
     * @param name -2
     * @param data -
     * @param opts -
     */
    add(name: NameType, data: DataType, opts?: JobsProOptions): Promise<JobPro<DataType, ResultType, NameType>>;
    /**
     * Adds an array of jobs to the queue. This method may be faster than adding
     * one job at a time in a sequence.
     *
     * @param jobs - The array of jobs to add to the queue. Each job is defined by 3
     * properties, 'name', 'data' and 'opts'. They follow the same signature as 'Queue.add'.
     */
    addBulk(jobs: {
        name: NameType;
        data: DataType;
        opts?: BulkJobProOptions;
    }[]): Promise<JobPro<DataType, ResultType, NameType>[]>;
    protected get Job(): typeof JobPro;
    /**
     * Get the group ids with jobs current jobs in them.
     *
     * TODO: Support group id filtering.
     */
    getGroups(start?: number, end?: number): Promise<{
        id: string;
        status: GroupStatus;
    }[]>;
    /**
     * Gets all the groups that are in a particular status.
     *
     * @param status - GroupStatus so we can filter by status
     * @param start - start index, used for pagination.
     * @param end - end index, used for pagination.
     * @returns  an array of objects with the group id and status.
     */
    getGroupsByStatus(status: GroupStatus, start?: number, end?: number): Promise<{
        id: string;
        count: number;
    }[]>;
    /**
     * Get the total number of groups with jobs in them.
     *
     */
    getGroupsCount(): Promise<number>;
    /**
     *
     * Get the total number of groups with jobs in them, in their different
     * statuses.
     *
     * @returns {
     *    waiting: number,
     *    limited: number,
     *    maxed: number,
     *    paused: number,
     * }
     *
     */
    getGroupsCountByStatus(): Promise<{
        waiting: number;
        limited: number;
        maxed: number;
        paused: number;
    }>;
    /**
     * Returns the number of jobs per priority.
     */
    getCountsPerPriorityForGroup(groupId: string, priorities: number[]): Promise<{
        [index: string]: number;
    }>;
    /**
     * Gets the count of all the jobs belonging to any group.
     *
     * @param limit - limit of groups per each iteration
     */
    getGroupsJobsCount(limit?: number): Promise<number>;
    /**
     * Get the given group status.
     *
     * @param groupId - The group id to get the status for.
     * @returns GroupStatus - The status of the group or null if the group does not exist.
     */
    getGroupStatus(groupId: string): Promise<GroupStatus>;
    /**
     * Get jobs that are part of a given group.
     *
     */
    getGroupJobs(groupId: string | number, start?: number, end?: number): Promise<JobPro<DataType, ResultType, NameType>[]>;
    /**
     * Gets the count of jobs inside a given group id.
     *
     * @param groupId -
     */
    getGroupJobsCount(groupId: string | number): Promise<number>;
    /**
     * Gets the active count of jobs inside a given group id. It will only return data when using concurrency per group,
     * otherwise it will return NaN.
     *
     * @param groupId -
     */
    getGroupActiveCount(groupId: string | number): Promise<number>;
    /**
     * Sets group concurrency.
     *
     * @param groupId -
     * @param concurrency -
     */
    setGroupConcurrency(groupId: string | number, concurrency: number): Promise<number>;
    /**
     * Deletes group concurrency.
     *
     * @param groupId -
     */
    deleteGroupConcurrency(groupId: string | number): Promise<number>;
    /**
     * Gets group concurrency.
     *
     * @param groupId -
     */
    getGroupConcurrency(groupId: string | number): Promise<number>;
    /**
     * Cleans all the jobs that are part of a group.
     *
     * @param groupId -
     */
    deleteGroup(groupId: string | number): Promise<void>;
    /**
     * Cleans all the groups in this queue
     *
     * @param groupId -
     */
    deleteGroups(): Promise<void>;
    /**
     * Returns the time to live for a rate limited key in milliseconds.
     * @param groupId - group identifier
     * @param maxJobs - max jobs to be considered in rate limit state. If not passed
     * it will return the remaining ttl without considering if max jobs is excedeed.
     * @returns -2 if the key does not exist.
     * -1 if the key exists but has no associated expire.
     * @see {@link https://redis.io/commands/pttl/}
     */
    getGroupRateLimitTtl(groupId: string | number, maxJobs?: number): Promise<number>;
    obliterate(opts?: {
        force?: boolean;
        count?: number;
    }): Promise<void>;
    /**
     * Pauses the processing of a specific group globally.
     *
     * Adding jobs requires a LUA script to check first if the paused list exist
     * and in that case it will add it there instead of the wait list or group list.
     */
    pauseGroup(groupId: string | number): Promise<boolean>;
    /**
     * Resumes the processing of a specific group globally.
     *
     * The method reverses the pause operation by resuming the processing of the
     * group.
     *
     * @param groupId - the group to resume
     */
    resumeGroup(groupId: string | number): Promise<boolean>;
    /**
     * Repairs a maxed group.
     *
     * It seems that in some unknown situations a group can become maxed although there
     * are no active jobs in the group. This function will try to repair this situation.
     *
     * @param groupId - the group to repair
     * @param concurrency - maximum number of simultaneous jobs that the workers can handle within a specific group
     */
    repairMaxedGroup(groupId: string, concurrency?: number): Promise<any>;
    /**
     * Repairs stalled key when you are migrating from v4 or below to v6 or above.
     * This key used a zset and now it uses a set, this is why this method is needed.
     * An error like: 'WRONGTYPE Operation against a key holding the wrong kind of
     * value' in moveStalledJobsToWait script is a good indicator of this change.
     * Note: Migration from v5 to v6 won't need to call this method
     */
    repairStalledKey(): Promise<any>;
}
