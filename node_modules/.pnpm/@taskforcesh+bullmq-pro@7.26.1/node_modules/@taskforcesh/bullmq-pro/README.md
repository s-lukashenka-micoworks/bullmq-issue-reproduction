# BullMQ Pro

BullMQ Professional edition

This module provides a drop-in replacement for the open source BullMQ edition. The module provides
some more advanced features, but cans also remove features that become "obsolete" with the more advanced
functionality.

## Groups

A queue can be divided into an unlimited amount of groups that can be defined dynamically as jobs are
being added to a queue.

A typical use case is when you have 1 processing queue but have an undetermined, potentially very large
amount of users but want to process the jobs in a fair manner, i.e. for example one user may have a lot of
jobs enqueued, and the rest just a few, still you do not want the busy user to monopolize the use of the queue.

Groups are processed in a round-robin fashion, so they can also be though as virtual queues, but with the
convenience of only needing one queue and that it is possible to grow or sink the number of groups depending
on the current load.

Example:

```ts
queue.add(
  'paint',
  { foo: 'bar' },
  {
    group: {
      id: 'user123',
    },
  },
);
```

### Road map

- Basic group implementation.
- Rate limiters per group.

```ts
const worker = new Worker(() => {}, {
  groups: {
    limit: {
      amount: 100,
      duratioon: 1000,
    },
  },
});
```

- Consume queue by batch (consume "up to"/"exactly" n jobs).
- Consume by group batches.
- Study if we can exploit Redis Cluster when using groups (like jobs can be distributed based on their groupId).
- Support "Snappy" compression for data and options.
- Cancellable jobs by supporting Observables.
- Store all job fields keys with 1 character to minimize size.
- Encode keys in data and opts in order to reduce size.
- Store integers in base 64 (not base 64 encoding) https://stackoverflow.com/questions/6213227/fastest-way-to-convert-a-number-to-radix-64-in-javascript/6573119 (less than 50% the size)
- Use the new worker threads for lighter concurrency https://nodejs.org/api/worker_threads.html
- O(1) priority jobs. Using the same concept as with groups, it is possible to implement priorities.
  Keep a zset with the jobs prioritized, consume from this set as it was a group list.
- Allow add indexes for "data" keypaths, so it would be efficient to do find/search/get operations of
  jobs based on these indexes.
